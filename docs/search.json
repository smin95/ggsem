[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ggsem: Build, Visualize, and Explore Path Diagrams Interactively",
    "section": "",
    "text": "Preface\nThe ggsem package introduces Interactive Parameter Visualization, a workflow that maps aesthetics to statistical parameters of a model. This allows users to directly manipulate model parameters (nodes, edges, labels, loops etc) with a mouse click to control their graphical properties while keeping their statistical models intact. This eliminates the rigid, manual process of creating publication-ready diagrams. ggsem supports visualization of multi-group SEM diagram (side-by-side or composite figure), combined SEM diagram (multi-group labels in one SEM diagram), a single group SEM diagram, as well as network diagrams.\nHere are some examples of multi-group SEM diagrams generated with ggsem (see Chapter 1).\nFigure 1. Separate SEM diagrams for two groups using one multi-group model with significantly different paths highlighted\nFigure 2. A combined SEM diagram of two groups using one multi-group model with one path highlighted\nFigure 3. Two Bayesian SEM diagrams side-by-side with unique color palettes with different orientations (+/- 90 degrees). Residuals are selectively shown on four nodes at customized orientations.\nFigure 4. One Frequentist and one Bayesian SEM diagrams side-by-side with different loop orientations (Quadratic vs. Graded options) and color palettes.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#workflow-expansion-not-replacement",
    "href": "index.html#workflow-expansion-not-replacement",
    "title": "ggsem: Build, Visualize, and Explore Path Diagrams Interactively",
    "section": "Workflow Expansion, Not Replacement",
    "text": "Workflow Expansion, Not Replacement\nggsem is designed as a workflow expander that integrates with about 9 classes of objects from 13 established packages, such as lavaan, tidySEM, OpenMx, semPlot, and igraph etc.\nggsem imports two types of outputs: Statistical Model Objects (e.g., fitted models from lavaan or OpenMx) to access parameters, and Visualization Objects (e.g., layouts from semPlot) to define the initial node positions. This dual-input system ensures maximum flexibility and reproducibility, and provides cross-package compatibility. In other words, you can:\n\nStart with your existing lavaan, blavaan, or OpenMx models\nImport visualizations from semPlot, tidySEM, lavaanPlot, or other packages\nThen use ggsem’s interactive environment to modify aesthetics of path diagrams\nStore metadata of figure output, and convert it to ggplot object in script-based workflow",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#visualization-through-model-awareness",
    "href": "index.html#visualization-through-model-awareness",
    "title": "ggsem: Build, Visualize, and Explore Path Diagrams Interactively",
    "section": "Visualization Through Model Awareness",
    "text": "Visualization Through Model Awareness\nggsem maintains awareness of your underlying statistical model. This means that you can achieve:\n\nParameter Control: Adjust visual properties through model parameters rather than manual positioning\nRelationship Preservation: Moving central nodes automatically suggests adjustments to connected elements\nStatistical Integration: Live parameter modification with immediate visual feedback, and highlighting paths that are statistically meaningful.\nMulti-Group Management: Creating composite visualizations across multiple models or groups using a multi-group model or separate model objects",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#complete-reproducibility",
    "href": "index.html#complete-reproducibility",
    "title": "ggsem: Build, Visualize, and Explore Path Diagrams Interactively",
    "section": "Complete Reproducibility",
    "text": "Complete Reproducibility\nggsem eliminates the reproducibility-breaking “PowerPoint step” from research workflows. Every adjustment—from color changes to layout modifications—is tracked. This means that all changes are exportable on script-based workflow into editable data files or images, as well as re-playable on the app.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "ggsem: Build, Visualize, and Explore Path Diagrams Interactively",
    "section": "Installation",
    "text": "Installation\nYou can install the stable version of ggsem from CRAN:\n\n# install.packages(c(\"colourpicker\", \"DT\", \"DiagrammeR\", \"memoise\", \"shiny\", \"shinyjs\", \"smplot2\", \"svglite\"), dependencies = TRUE)\n\ninstall.packages(\"ggsem\") # version 0.9.6\n\nDevelopment version of ggsem can also be downloaded from Github:\n\ndevtools::install_github(\"smin95.com/ggsem\")\n\nYou can launch the app with this code below:\n\nlibrary(ggsem)\nggsem()\n\nIt opens a blank canvas, where you can draw diagrams in two different ways: 1) Code-free visualization, 2) Integrated Visualization.\n\n\n\n\n\nFigure 1. The ggsem App",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#sem-and-network-visualizations",
    "href": "index.html#sem-and-network-visualizations",
    "title": "ggsem: Build, Visualize, and Explore Path Diagrams Interactively",
    "section": "SEM and Network Visualizations",
    "text": "SEM and Network Visualizations\nggsem supports two complementary approaches tailored to different user needs:\n\n1. Code-free Visualization: For New Users\nFor users without extensive R programming experience, ggsem provides a complete interface for creating sophisticated SEM and network diagrams from start to finish. This approach significantly lowers barriers to creating publication-quality visualizations without requiring specialized file formats or coding expertise. ggsem is also equipped with Generative AI models that could translate statistical models into natural language or vice versa.\n\n\n2. Integrated Visualization\nFor advanced users, ggsem serves as a workflow enhancer that imports pre-existing models and visualizations from established R packages. This allows researchers to leverage their preferred analysis tools while gaining interactive refinement capabilities for final diagram polishing.\n\nLoading Pre-existing SEM and Network Objects\nggsem provides direct integration with established R packages, allowing you to begin with pre-existing model objects and visualizations:\n\n\nSupported Object Types\nggsem accepts objects from multiple popular R packages:\nSEM Objects (More Info on Chapter 10):\n\nlavaan: Fitted models (single or multi-group) from lavaan package\nblavaan: Fitted Bayesian models (single or multi-group) from blavaan package\nsemPlot: Objects (qgraph class) from lavaan or blavaan models\n\nAlso compatible with customized SEM layouts outputs created with semptools package\n\nsem_graph: Single or multi-group objects from tidySEM package.\nMxRAMModel: OpenMx models (single or multi-group)\n\nAlso compatible with model outputs created with the umx package.\n\nmplusObject: Mplus models\ngrViz: Objects from lavaanPlot package (which depends on diagrammeR package to render graphics)\n\nNetwork Objects (More Info on Chapter 11):\n\nigraph: igraph network objects\nnetwork: network package objects\nqgraph: qgraph network objects (not SEM)",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "workflow_overview.html",
    "href": "workflow_overview.html",
    "title": "1  A Quick Overview on Multi-Group SEM Workflow",
    "section": "",
    "text": "1. ggsem_builder() - Initialization\nggsem_builder()",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>A Quick Overview on Multi-Group SEM Workflow</span>"
    ]
  },
  {
    "objectID": "workflow_overview.html#figure-outputs",
    "href": "workflow_overview.html#figure-outputs",
    "title": "1  A Quick Overview on Multi-Group SEM Workflow",
    "section": "1.1 Figure Outputs",
    "text": "1.1 Figure Outputs\nThe code above automatically loads two SEM diagrams into the canvas, where you can assign unique color palettes in the app.\n\n\n\n\n\nFigure 1. Two SEM diagrams with unique color palettes\n\n\n\n\nSince ggsem directly has access to the model statistics, it can also highlight paths that are significantly different between two groups (schools).\n\n\n\n\n\nFigure 2. Two SEM diagrams with highlighted paths that are significantly different\n\n\n\n\nThrough interactive parameter visualization, you can change any visual aspects while keeping the model intact. Here, the aesthetics of the textual node have been modified.\n\n\n\n\n\nFigure 3. Interactive parameter visualization: Interactively modify the aesthetics of parameter ‘textual’ node through a dynamic dropdown\n\n\n\n\n\n\n\n\n\nFigure 4. Two SEM diagrams whose ‘textual’ nodes’ aesthetics have been modified through interactive parameter visualization\n\n\n\n\nFinally, group labels can automatically be added based on the groups’ name introduced in add_group().\n\n\n\n\n\nFigure 5. Two SEM diagrams whose Texture nodes’ aesthetics have been modified through interactive parameter visualization\n\n\n\n\nYou can also combine the two SEM diagrams into one diagram, and align edge labels side-by-side.\n\n\n\n\n\nFigure 6. Combine multiple SEMs across groups into one\n\n\n\n\n\n\n\n\n\nFigure 7. A combined SEM diagram with aligned edge labels\n\n\n\n\nNotice that the edge label of the path between visual and speed nodes overlap with the edge label between textual node and its intercept. So we can increase the curvature of the curved line. The path is colored in blue to highlight the change. These are achieved via interactive parameter visualization.\n\n\n\n\n\nFigure 8. Interactive parameter visualization: Interactively modify the aesthetics of edge between visual and speed nodes through a dynamic dropdown\n\n\n\n\n\n\n\n\n\nFigure 9. A combined SEM diagram with aligned edge labels\n\n\n\n\nYou can replay this workflow using undo and redo buttons in the app menu by loading the metadata (that I have created from this session) that app produces.\n\nggsem() # run the app and load the metadata\n\n\n\n\n\n\nFigure 10. Load metadata (RDS) file and replay the session’s history\n\n\n\n\nTo reproduce Figure 5, you can download the metadata from online, and load it in the app.\nwww.smin95.com/fig5.rds\nThis image can also be loaded in script-based workflow using these codes below into a ggplot output directly using the metadata (more information in Chapter 17).\n\nlibrary(tidyverse)\nlibrary(ggsem)\n\nmetadata_fig5 &lt;- readRDS('fig5.rds') # load the metadata from your directory\nfig5 &lt;- metadata_to_ggplot(metadata_fig5) # convert the metadata to a ggplot object\n\n\nsave_figure('fig5.png', fig5)\n\n\n\n\n\n\nFigure 11. SEM figure saved from script-based workflow by loading metadata via code\n\n\n\n\nIf this workflow interests you, please continue to read the book. The next chapter describes the ggsem app in general, which is straightforward to use.",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>A Quick Overview on Multi-Group SEM Workflow</span>"
    ]
  },
  {
    "objectID": "app_overview.html",
    "href": "app_overview.html",
    "title": "2  App Overview",
    "section": "",
    "text": "2.1 Overview of the ggsem App Interface\nThe ggsem application provides an interactive environment for creating and customizing network diagrams and Structural Equation Modeling (SEM) visualizations (Figure 1). The interface is logically divided into two main sections: the plotting canvas on the right and the control sidebar on the left.\nFigure 1. Overview of the ggsem App interface",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>App Overview</span>"
    ]
  },
  {
    "objectID": "app_overview.html#the-plotting-canvas",
    "href": "app_overview.html#the-plotting-canvas",
    "title": "2  App Overview",
    "section": "2.2 The Plotting Canvas",
    "text": "2.2 The Plotting Canvas\nThis is the primary workspace where your diagrams are rendered in real-time (Figure 2). As you add elements and adjust settings in the sidebar, the visualization here updates interactively.\n\n\n\n\n\nFigure 2. The Plotting Canvas that gets updated in real-time",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>App Overview</span>"
    ]
  },
  {
    "objectID": "app_overview.html#the-control-sidebar",
    "href": "app_overview.html#the-control-sidebar",
    "title": "2  App Overview",
    "section": "2.3 The Control Sidebar",
    "text": "2.3 The Control Sidebar\n\n\n\n\n\nFigure 3. The Control Sidebar with Dynamic Menus\n\n\n\n\nThe left sidebar (Figure 3) contains all the tools for building and customizing your diagram. It is organized into several key areas:\n\nElement Selection & Management\n\nElement Type: This dropdown menu is the starting point for all creation. It allows you to select the type of element you wish to add or modify. The options are:\n\nPoint: For adding individual nodes.\nLine: For drawing edges, connectors, or arrows between points.\nText Annotation: For adding labels or mathematical expressions.\nSelf-loop Arrow: For creating circular arrows that connect a node to itself.\nSEM Diagram: A specialized section for generating path diagrams from lavaan model syntax, with optional AI-assisted model generation.\nNetwork Diagram: For creating network visualizations directly from edge list or adjacency matrix CSV files.\nAesthetic Grouping: For applying bulk changes to the appearance and position of multiple elements at once.\n\nLayer Ordering: This feature controls the visual stacking order (z-index) of the elements on the canvas. You can drag the layers (Annotations, Points, Lines, Self-loop arrows) to reorder them. The top item in the list will appear in the front, potentially obscuring elements in layers below it. The default order ensures points are displayed on top of lines.\nGroup Assignment: When adding new elements, you can assign them to a specific aesthetic group. This feature allows you to later modify all elements within that group simultaneously (e.g., change the color of all points in “Group 1”).\n\nViewport Controls\n\nThese controls adjust your view of the canvas without altering the underlying data.\n\nZoom Control: A slider and numeric input to zoom the canvas in and out (from 0.1x to 10x de-magnification).\nX-Level & Y-Level Control: Sliders and numeric inputs to pan the canvas horizontally and vertically. This is essential for navigating diagrams that extend beyond the initial viewport.\n\n\nAction History & Canvas Management\n\nUndo/Redo Buttons: Revert or reapply your recent actions. These are also accessible via standard keyboard shortcuts (Ctrl+Z and Ctrl+Y). The app maintains a full history of your session.\nClear Button: Removes all elements from the canvas to start a new diagram.\n\nDynamic Element-Specific Panels\n\nThis is the most dynamic area of the sidebar. Its content changes contextually based on your selection in the Element Type dropdown, and remembers settins for each Group in Which Group to Modify dropdown. Each panel provides detailed controls for the chosen element:\n\nFor Points: Options to draw individual points, automatically arrange unlocked points into layouts (circle, grid, star, etc.), apply color gradients, lock points to prevent modification, and perform bulk aesthetic shifts.\nFor Lines: Controls for manually drawing straight or curved lines/arrows, auto-generating edges between unlocked points based on connection rules (e.g., fully connected, nearest neighbor), applying gradients, and bulk editing.\nFor Text Annotations: Tools for adding single text labels or math expressions, auto-generating labels on unlocked points (as numbers, letters, or custom text), and managing text aesthetics in groups.\nFor Self-loop Arrows: Inputs for creating individual loops or auto-generating them on unlocked points, with controls for radius, gap size, orientation, and gradient effects.\nFor SEM Diagrams: A comprehensive suite of tools including:\n\nData & Model Input: Upload a CSV dataset and define your model using lavaan syntax, with an innovative AI assistant to help generate the syntax from your data structure or a natural language description.\nLayout & Statistics: Choose from various SEM-specific layouts and display model fit indices.\nInteractive Customization: Fine-tune the appearance and positions of individual nodes, edges, and labels, or modify them in groups.\n\nFor Network Diagrams: Functionality to upload network data (CSV), select a layout algorithm, and extensively customize the aesthetics of nodes, edges, and labels, including edge curvature and scaling width by weight.\nFor Aesthetic Grouping: A centralized panel for managing elements by their group labels. You can shift positions, change aesthetics, rename groups, show/hide group labels, align groups, or delete/lock all elements within a specific group.\n\n\n\n\n2.3.1 Real-time Data Tables\nAs you add graphical elements to the canvas, four interactive data tables are automatically updated in the Output Tables section:\n\nPoints Table - Records all nodes with their coordinates, colors, sizes, shapes, and group assignments\nLines Table - Contains all edges with start/end coordinates, line types, colors, widths, and arrow specifications\nAnnotations Table - Stores text labels with positioning, font properties, colors, and mathematical expressions\nSelf-loop Arrows Table - Tracks circular arrows with center points, radii, gap sizes, and orientation angles\n\nKey features of the data tables:\n\nDirect Editing: Click on any cell to modify values directly (X/Y coordinates, colors, sizes, etc.)\nBulk Operations: Use the action buttons above each table to delete, lock, or unlock selected or all elements\nVisual Feedback: Changes made in the tables instantly update the visualization\nGroup Management: See and manage the group assignments for all elements",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>App Overview</span>"
    ]
  },
  {
    "objectID": "app_overview.html#quick-workflow-example",
    "href": "app_overview.html#quick-workflow-example",
    "title": "2  App Overview",
    "section": "2.4 Quick Workflow Example",
    "text": "2.4 Quick Workflow Example\nWhile the most powerful feature of ggsem is its ability to create and customize Structural Equation Models, I present a typical workflow to generate graphical elements such as points and lines.\n\n2.4.1 Part 1: Draw Points\n\n\n\n\n\nFigure 4. Workflow that generates two separate points.\n\n\n\n\n\nChoose an Element Type from the dropdown (e.g., Point).\nUse the options in the Sidebar to add elements to the canvas (e.g., click “Add Point”).\n\nClick Add Point without changing any settings. This creates a black point at the origin (x = 0, y = 0).\nCreate another point. But change the settings so that its coordinate is at x = 15, y = 15, and modify its color setting.\n\nUse the Viewport Controls to zoom and pan for a better view.\nTry modifying the aesthetics (points) of existing elements by clicking Apply Changes.\n\nAny changes done via Apply Changes will be applied to unlocked points.\nTry to Lock points to see what happens.\n\nUse Undo/Redo freely to experiment, as well as directly edit information in the Output Tables. Any changes will update the plotting canvas in real-time.\n\n\n\n2.4.2 Part 2: Connect the Points with a Line\n\n\n\n\n\nFigure 5. Auto-generate edge between existing points.\n\n\n\n\n\nSwitch the Element Type (e.g., to Line) to connect your points, either manually or using the “Auto-generate Edges” button.\n\nEdges are formed only between unlocked points.\nUndo your actions and experiment with the locking mechanism. Try to Lock points and see if edges can be formed automatically using “Auto-generate Edges” button.\n\n\nNote: Rows are green if they are unlocked. They become red if they are locked.\n\n\n2.4.3 Part 3: Label Points with Texts\n\n\n\n\n\nFigure 6. Auto-generate text annotation on unlocked points.\n\n\n\n\n\nSwitch the Element Type (to Annotation) to label your points automatically using the “Auto-generate Annotations” button.\n\nAesthetics options can be accessed in Draw Individual Annotations sub-menu.\nMake the labels visible by choosing a white (#FFFFFF) or similar color.",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>App Overview</span>"
    ]
  },
  {
    "objectID": "app_overview.html#export-import-csv-files",
    "href": "app_overview.html#export-import-csv-files",
    "title": "2  App Overview",
    "section": "2.5 Export & Import CSV Files",
    "text": "2.5 Export & Import CSV Files\n\n\n\n\n\nFigure 7. Save the outputs in CSV or image files.\n\n\n\n\nSaving Your Work:\n\nUse the “Choose CSV to Download” dropdown to select which element type to export\nClick “Download Selected CSV” to save individual element tables\n\nThese CSV files contain all the aesthetic properties needed to recreate your visualization\n\n\nResuming Your Work:\nYou can continue to work across multiple sessions or share visualizations with collaborators.\n\nUse the file inputs to upload previously saved CSV files\nLoad Points CSV, Lines CSV, Annotations CSV, and Self-loop Arrows CSV to restore your entire diagram",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>App Overview</span>"
    ]
  },
  {
    "objectID": "app_overview.html#figure-export-options",
    "href": "app_overview.html#figure-export-options",
    "title": "2  App Overview",
    "section": "2.6 Figure Export Options",
    "text": "2.6 Figure Export Options\nggsem allows you to download your diagrams in multiple formats:\n\nPNG & JPEG - For presentations and web use\nPDF & SVG - For publication-quality vector graphics\n\nCustom Export Settings:\n\nFixed Aspect Ratio (unchecked by default) - Maintains 1:1 proportions\nSpecify X/Y Range - Define custom viewport dimensions for asymmetric figures\nRange Inputs - Set minimum and maximum values for precise cropping\n\nFor your diagram, you can:\n\nDouble-check if the Fixed Aspect Ratio box is unchecked.\nDo not provide any specific x or y ranges (Figure 6). Then the app will automatically determine the appropriate range.\nSave the image in PNG file.\n\n\n\n\n\n\nFigure 8. Figure generated from the example.",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>App Overview</span>"
    ]
  },
  {
    "objectID": "app_overview.html#recreate-your-figure-by-code",
    "href": "app_overview.html#recreate-your-figure-by-code",
    "title": "2  App Overview",
    "section": "2.7 Recreate Your Figure by Code",
    "text": "2.7 Recreate Your Figure by Code\nR-savvy users might want to access the figure in code form to freely decompose and modify each component. This is possible because ggsem relies on ggplot2 framework to render plots using these steps and CSV outputs from the app:\n\nlibrary(ggsem)\n\nDocumentation website of ggsem: smin95.github.io/ggsem/\n\npoints &lt;- read.csv('app_overview/points.csv') \nlines &lt;- read.csv('app_overview/lines.csv') \nannotations &lt;- read.csv('app_overview/annotations.csv') \n\nggsem_data &lt;- list(points, lines, annotations) # Put them in a list, any order is fine\n\n\nLoad ggsem library into memory.\nLoad the CSV files from your directory and save them into objects\n\npoints can store the points.csv file\nlines can store the lines.csv file\nannotations can store the annotations.csv file\n\nCreate a list with the three objects stored (e.g., ggsem_data).\nUse csv_to_ggplot() to convert the CSVs into ggplot object (see below). Axis ranges are automatically determined similarly to how the ggsem app sets for saving image outputs.\n\n\nplot1 &lt;- csv_to_ggplot(ggsem_data)\n\nCoordinate system already present. Adding new coordinate system, which will\nreplace the existing one.\n\n\n\nSave the image using save_figure() from the ggsem package.\n\nThis function has no input for width or height because the figure ratio can be disrupted if they are manually chosen (due to how ggplot2 stores graphics).\nsave_figure() automatically determines the appropriate width and height.\n\n\n\nsave_figure('plot1.png', csv_to_ggplot(ggsem_data))\n\n\n\n\n\n\nFigure 9. Figure generated from the CSV files outside the ggsem app.\n\n\n\n\n\n2.7.1 Modify the graphics outside the app\nYou can directly modify the width of the edge connecting the points at the level of the data frame lines.\n\nlines\n\n  x_start y_start    x_end    y_end ctrl_x ctrl_y ctrl_x2 ctrl_y2\n1 2.58211 2.58211 12.79289 12.79289     NA     NA      NA      NA\n  curvature_magnitude curvature_asymmetry rotate_curvature          type\n1                   0                   0            FALSE Straight Line\n    color end_color color_type gradient_position width alpha arrow arrow_type\n1 #000000        NA     Single                NA     1     1    NA         NA\n  arrow_size two_way lavaan network line_style locked group\n1         NA      NA  FALSE   FALSE      solid  FALSE     1\n\n\nThe width of the line is set to 1, which we can increase to 2.\n\nlines$width &lt;- 2\n\nNow, as before, convert the updated CSV files to ggplot object again using csv_to_ggplot(), and save the object into an image file using save_figure().\n\nggsem_data &lt;- list(points, lines, annotations) # Put them in a list, any order is fine\n\nplot2 &lt;- csv_to_ggplot(ggsem_data)\n\nCoordinate system already present. Adding new coordinate system, which will\nreplace the existing one.\n\n\n\nsave_figure('plot2.png', plot2)\n\n\n\n\n\n\nFigure 10. Figure generated from the CSV files outside the ggsem app after edge modification.",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>App Overview</span>"
    ]
  },
  {
    "objectID": "autogenerate_workflow.html",
    "href": "autogenerate_workflow.html",
    "title": "3  Batch Graphical Functions",
    "section": "",
    "text": "3.1 Generate Graphics\nIn this section, we will generate graphical elements in batch using lock/unlock system in the app. First, launch the application locally.\nlibrary(ggsem)\nggsem()",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Batch Graphical Functions</span>"
    ]
  },
  {
    "objectID": "autogenerate_workflow.html#generate-graphics",
    "href": "autogenerate_workflow.html#generate-graphics",
    "title": "3  Batch Graphical Functions",
    "section": "",
    "text": "3.1.1 Points\n\n\n\n\n\nFigure 1. First part of the example: generate 10 points in tandem.\n\n\n\n\nFirst, we will start by creating a foundation of points:\n\nClick the Add Point button ten times to generate ten individual points.\n\nYou can confirm this in the Points Table below the plot, which should show ten rows. The green background in the rows from the table indicates these points are “unlocked,” meaning they can be modified as a group.\n\n\n\n\n\n\nFigure 2. First part of the example: arrange the position and color of the 10 points.\n\n\n\n\nTo arrange these points automatically, open the “Sort Points in Layout” panel.\n\nFrom the Layout Type dropdown, select “Curved Line” and click the Auto-layout Points button.\nThe points will reorganize into a curved path.\n\nYou can fine-tune the curve’s shape and the spacing between points using the Curvature Magnitude and Point Distance inputs.\nNext, let’s apply a color gradient. Set the Gradient Start Color to #CBAEE3 (light purple) and the Gradient End Color to #6B468C (dark purple). Click the Apply Gradient button to distribute these colors across the unlocked points.\n\n\n\n\n\nFigure 3. First part of the example: add 11th point in the center of the layout.\n\n\n\n\nFinally, we’ll add a central point. In the “Draw Individual Points” panel, set the X Coordinate to 0, Y Coordinate to -5, and choose a color like #E38FD5 (pink). Click Add Point to place it.\n\n\n\n3.1.2 Lines\n\n\n\n\n\nFigure 4. Second part of the example: auto-generate multiple edges connecting unlocked points.\n\n\n\n\nNow, we can automatically generate lines (edges) to connect our unlocked points. In this case, we will connect the central pink point to all the points in the purple curved line.\n\nOpen the “Auto-generate Edges to Connect Nodes” panel.\nFrom the Choose Edge Connection Type dropdown, select “Connect to Particular Node”. This will reveal a new dropdown, “Select Central Node,” which lists all unlocked points. Select the point you just added (it will be the 11th point).\nSet the Edge Spacing to 0.1 (this controls the gap between the line and the point’s border) and the Edge Width to 1.5.\nClick the Auto-generate Edges button to draw the connecting lines.\n\nTo color these lines with a gradient, use the controls in the same panel:\n\nSet the Gradient Start Color to #BA487B (pink) and the Gradient End Color to #3C3B3D (dark gray).\nTo make the pink more dominant, adjust the Gradient Intersection slider to 0.8 (a value closer to 1 gives more weight to the start color). Click Apply Gradient to update the lines.\n\n\n\n3.1.3 Text Annotations\n\n\n\n\n\nFigure 5. Third part of the example: auto-generate node labels on unlocked points.\n\n\n\n\nFinally, we will label the points. We want to number the purple points but not the central pink one.\n\nTo prevent the pink point from being annotated, find its row in the Points Table, select it, and click the Lock Selected Point(s) button.\n\nLocking it ensures it won’t be affected by auto-generation functions.\n\nOpen the “Auto-generate Texts on Points” panel. Ensure the Text Color is set to #FFFFFF (white) and click the Auto-generate Annotations button.\n\nThis will label all the unlocked (purple) points with sequential numbers, starting from 1.\n\nTo add a custom label to the locked pink point, use the “Draw Individual Annotations” panel. Set the Color to #FFFFFF (white), the Fontface to bold, and enter A.\nClick Add Annotation to place the custom text label.\n\nWe have now automatically generated and customized points, lines, and text annotations using the lock/unlock system to control which elements are modified. The same principles apply to creating and styling self-loop arrows and applying gradients to them.\n\n\n3.1.4 Save the image output\n\nDouble-check if the Fixed Aspect Ratio box is unchecked.\nDo not provide any specific x or y ranges. Then the app will automatically determine the appropriate range.\nSave the image in PNG file.\n\nHere’s the image output saved in PNG format.\n\n\n\n\n\nFigure 6. Final output from the example.",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Batch Graphical Functions</span>"
    ]
  },
  {
    "objectID": "autogenerate_workflow.html#reproduce-the-graphics-outside-the-app",
    "href": "autogenerate_workflow.html#reproduce-the-graphics-outside-the-app",
    "title": "3  Batch Graphical Functions",
    "section": "3.2 Reproduce the Graphics Outside the App",
    "text": "3.2 Reproduce the Graphics Outside the App\nFollow these steps to render your ggsem creation directly in R:\n\nLoad the package: Start by loading the ggsem library into your R session.\nImport Data: Read your saved CSV files (points.csv, lines.csv, annotations.csv) from your directory, storing them as separate objects (e.g., points, lines, annotations).\nCombine: Create a single list (e.g., ggsem_data) containing these three data frames.\nGenerate Plot: Pass this list to the csv_to_ggplot() function. It will convert the data into a ggplot object and automatically set the axis limits, just as the app does when you export an image.\nExport: Save the plot object (e.g., plot3) using save_figure(). There is no need to specify width or height, as the function determines these automatically to maintain the correct aspect ratio and prevent a distorted figure.\n\n\nlibrary(ggsem)\n\nDocumentation website of ggsem: smin95.github.io/ggsem/\n\npoints &lt;- read.csv('batch/points_batch.csv') \nlines &lt;- read.csv('batch/lines_batch.csv') \nannotations &lt;- read.csv('batch/annotations_batch.csv') \n\nggsem_data &lt;- list(points, lines, annotations) # Put them in a list, any order is fine\n\n\nplot3 &lt;- csv_to_ggplot(ggsem_data)\n\nCoordinate system already present. Adding new coordinate system, which will\nreplace the existing one.\n\n\n\nsave_figure('plot3.png', plot3)\n\n\n\n\n\n\nFigure 7. Final output recreated from the CSV files outside the app.\n\n\n\n\nYou can control the amount of empty white space by either reducing or increasing it using the function adjust_axis_space(). It provides fine-grained control over the plot’s margins, letting you crop each side by a specific percentage. The main arguments are:\n\nx_adjust_left_percent: Shrinks the left-side x-axis boundary.\nx_adjust_right_percent: Shrinks the right-side x-axis boundary.\ny_adjust_bottom_percent: Shrinks the bottom y-axis boundary.\ny_adjust_top_percent: Shrinks the top y-axis boundary.\n\nThere is some additional white space on the x-axis in plot3. So, we will remove 17% of the space from both the left and right sides of the x-axis range. Save this modified object using save_figure() as an image file named plot3b.png.\n\nplot3b &lt;- adjust_axis_space(plot3, x_adjust_right_percent = -17, x_adjust_left_percent = -17)\n\n\nsave_figure('plot3b.png', plot3b)\n\n\n\n\n\n\nFigure 8. Final output recreated from the CSV files outside the app after chipping away outer white space.",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Batch Graphical Functions</span>"
    ]
  },
  {
    "objectID": "autogenerate_workflow.html#summary",
    "href": "autogenerate_workflow.html#summary",
    "title": "3  Batch Graphical Functions",
    "section": "3.3 Summary",
    "text": "3.3 Summary\nIn summary, by creating a set of unlocked points, we were able to automatically generate edges and annotations with minimal effort. This demonstrates the efficiency of ggsem’s lock/unlock system, which allows for batch editing of specific elements. This workflow empowers users to efficiently build complex diagrams, such as networks and SEMs, for educational or illustrative purposes.",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Batch Graphical Functions</span>"
    ]
  },
  {
    "objectID": "sem_overview.html",
    "href": "sem_overview.html",
    "title": "4  SEM Diagram Functions Overview",
    "section": "",
    "text": "4.1 Model Specification & Data Input\nFigure 1. Model Specification & Data Input: Users can manually specify a model or ask assistance from GenAI embeded in the app.\nggsem provides multiple, flexible pathways to define your Structural Equation Model, catering to both traditionalists and those seeking a more guided, AI-assisted approach.",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>SEM Diagram Functions Overview</span>"
    ]
  },
  {
    "objectID": "sem_overview.html#model-specification-data-input",
    "href": "sem_overview.html#model-specification-data-input",
    "title": "4  SEM Diagram Functions Overview",
    "section": "",
    "text": "4.1.1 Lavaan Syntax Input\nFor users already familiar with SEM, the Lavaan Syntax Input offers a direct and powerful interface. A sample model string is pre-loaded, which you can freely modify, replace, or use as a template for your own syntax.\nggsem uses the standard syntax from the widely adopted lavaan package in R. This syntax allows you to define your model using a few key operators, which ggsem then translates directly into visual elements on the diagram:\n\n=~ (Measured By): Defines a latent variable and the observed variables that measure it.\n\nExample: visual =~ x1 + x2 + x3 means the latent variable “visual” is measured by the three observed indicators x1, x2, and x3.\nVisual: Drawn as a one-way arrow from the latent variable to each of its indicators.\n\n~ (Regressed On): Defines a regression path between variables.\n\nExample: y ~ x1 + x2 means variable “y” is regressed on predictors “x1” and “x2”.\nVisual: Drawn as a one-way arrow from the predictor to the outcome variable.\n\n~~ (Covariance/Correlation): Defines a covariance or correlation between two variables.\n\nExample: visual ~~ textual allows the latent variables “visual” and “textual” to covary.\nVisual: Drawn as a curved, two-way arrow between the variables.\n\n\nThis method supports the full spectrum of lavaan model types, including:\n\nSEM: Full structural equation models with latent and observed variables\nCFA: Confirmatory Factor Analysis\nEFA: Exploratory Factor Analysis (with controls for the number of factors and rotation methods)\nGrowth: Latent growth curve models\n\n\n\n4.1.2 AI-Assisted Model Generation\nFor those new to SEM or seeking a creative starting point, ggsem includes an AI Assistant using five models of Generative AI (Google Gemini, OpenAI GPT, Mistral AI, Anthropic Claude and Ollama). This feature helps bridge the gap between your theoretical understanding and the technical syntax required by lavaan. More information on this feature is described in the next chapter.\n\n\n4.1.3 Data Integration\nYou can upload your data as a CSV file, which ggsem interprets as a standard data frame, compatible with the lavaan package. The app ensures your data is correctly paired with your model—whether written by hand or generated by the AI—for estimation and visualization.\n\n4.1.3.1 Data Format Requirements\nYour CSV file should be structured as a typical dataset for statistical analysis, following the same format used by the lavaan package. Here is an example from the built-in HolzingerSwineford1939 dataset:\n\nlibrary(lavaan)\nhead(HolzingerSwineford1939) # first six rows\n\n  id sex ageyr agemo  school grade       x1   x2    x3       x4   x5        x6\n1  1   1    13     1 Pasteur     7 3.333333 7.75 0.375 2.333333 5.75 1.2857143\n2  2   2    13     7 Pasteur     7 5.333333 5.25 2.125 1.666667 3.00 1.2857143\n3  3   2    13     1 Pasteur     7 4.500000 5.25 1.875 1.000000 1.75 0.4285714\n4  4   1    13     2 Pasteur     7 5.333333 7.75 3.000 2.666667 4.50 2.4285714\n5  5   2    12     2 Pasteur     7 4.833333 4.75 0.875 2.666667 4.00 2.5714286\n6  6   2    14     1 Pasteur     7 5.333333 5.00 2.250 1.000000 3.00 0.8571429\n        x7   x8       x9\n1 3.391304 5.75 6.361111\n2 3.782609 6.25 7.916667\n3 3.260870 3.90 4.416667\n4 3.000000 5.30 4.861111\n5 3.695652 6.30 5.916667\n6 4.347826 6.65 7.500000\n\n\nKey Structure Notes:\n\nThe first column can be a unique identifier (e.g., id)\nSubsequent columns contain your measured variables (e.g., x1 to x9)\nColumn names should match the variable names used in your lavaan syntax\nMissing data should be represented as blank cells or NA\nThe file should not contain any special formatting or merged cells\n\nAlternatively, you can test this with a sample dataset by running in R:\n\ndf1 &lt;- read.csv('https://www.smin95.com/HolzingerSwineford1939.csv', check.names = FALSE)\nhead(df1)\n\n  id sex ageyr agemo  school grade       x1   x2    x3       x4   x5        x6\n1  1   1    13     1 Pasteur     7 3.333333 7.75 0.375 2.333333 5.75 1.2857143\n2  2   2    13     7 Pasteur     7 5.333333 5.25 2.125 1.666667 3.00 1.2857143\n3  3   2    13     1 Pasteur     7 4.500000 5.25 1.875 1.000000 1.75 0.4285714\n4  4   1    13     2 Pasteur     7 5.333333 7.75 3.000 2.666667 4.50 2.4285714\n5  5   2    12     2 Pasteur     7 4.833333 4.75 0.875 2.666667 4.00 2.5714286\n6  6   2    14     1 Pasteur     7 5.333333 5.00 2.250 1.000000 3.00 0.8571429\n        x7   x8       x9\n1 3.391304 5.75 6.361111\n2 3.782609 6.25 7.916667\n3 3.260870 3.90 4.416667\n4 3.000000 5.30 4.861111\n5 3.695652 6.30 5.916667\n6 4.347826 6.65 7.500000\n\n\n\n\n4.1.3.2 Flexible Workflow\nThese input methods are not mutually exclusive. You can:\n\nUse the AI to generate a base model from your data and then refine the syntax manually\nWrite your own syntax and use the AI for suggestions on improvement or alternative specifications\nIterate between AI suggestions and manual edits to rapidly develop and test different model structures\n\nThis flexibility supports various user preferences:\n\nDirect Users: Manually select model type and upload data directly in the app\nExpert Users: Analyze models with preferred packages, then load results into ggsem for visualization and layout optimization using AI suggestions",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>SEM Diagram Functions Overview</span>"
    ]
  },
  {
    "objectID": "sem_overview.html#the-interactive-workflow-cycle",
    "href": "sem_overview.html#the-interactive-workflow-cycle",
    "title": "4  SEM Diagram Functions Overview",
    "section": "4.2 The Interactive Workflow Cycle",
    "text": "4.2 The Interactive Workflow Cycle\nggsem operates on a three-stage workflow that maintains a clear distinction between exploratory design and finalized output, giving you complete control over the entire SEM creation process.\n\n4.2.1 The Three-Stage Process\nStage 1: “Draw a SEM” - Initial Generation\nIn this stage, you can draw SEM by clicking the Draw a SEM button, which generates the initial diagram from your lavaan model syntax and data (optional in the app) and has several features:\n\nAutomatic Layout: Applies your chosen layout algorithm (Tree, Circle, Spring, etc.) to create a logically structured diagram\nStatistical Integration: Populates the diagram with parameter estimates, significance indicators, and fit statistics based on your actual data\nEditable State: All generated elements are marked with lavaan = TRUE in the output tables, keeping them ready for further modification in the SEM Diagram dynamic menu.\n\nStage 2: “Apply Changes” - Visual Editing Over SEM Elements\nThis stage focuses on applying broad visual customizations across your entire diagram. When you press “Apply Changes”, ggsem performs comprehensive visual updates while maintaining statistical integrity.\nA. Global Node Settings Apply consistent styling across all nodes by type:\n\nType-Specific Styling: Separate controls for latent, observed, and intercept nodes\nShape Customization: Circle, square, rectangle, oval, triangle, and diamond shapes with adjustable width-height ratios\nSize & Color Control: Independent adjustments to node sizes, colors, border properties, and transparency levels\n\nB. Global Edge Settings Standardize the appearance of all connections:\n\nArrow Customization: Open/closed types with adjustable size and positioning\nLine Properties: Color, width, transparency, and style controls (solid, dashed, dotted)\nEndpoint Spacing: Adjusts spacing between edges and nodes to prevent visual crowding\nCovariance Curvature: Controls curvature magnitude, rotation, and asymmetry for two-way arrows\n\nC. Global Annotation Settings Maintain consistent text formatting throughout:\n\nNode Labels: Type-specific styling with different text properties for latent vs. observed variable labels\nEdge Labels: Automatic display of model estimates with consistent formatting\nText Properties: Font family, size, color, transparency, angle, and fontface customization\n\nD. Global Self-loop Arrow Settings Determine the style of residual arrows:\n\nShow Residual Variances checkbox show self-loop residual arrows\nThe aesthetics can then be edited globally via All Loop Arrows submenu\n\nStage 3: “Finalize a SEM” - SEM Options Lock\n\nParametric Disconnection: Severs the live connection between statistical parameters and visual elements\nEdit Protection: Changes lavaan column to FALSE in output tables, making elements immune to further “Apply Changes” operations in the SEM Diagram menu. Rows will become green when lavaan is set to FALSE; green rows are modifiable using options in the dynamic Aesthetic Grouping menu in Element Type.\nExport Preparation: Optimizes the diagram for high-quality publication output\n\nStatistical Synchronization (Preserved): While focusing on visual changes, the system maintains:\n\nParameter Estimate Updates: All statistical annotations reflect current model values\nSignificance Indicators: Asterisks and highlighting remain accurate\nLive Connection: The vital link between statistical parameters and visual representation is preserved\n\nEditability Preservation: All elements remain editable (lavaan = TRUE) for continuous refinement.",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>SEM Diagram Functions Overview</span>"
    ]
  },
  {
    "objectID": "sem_overview.html#example-1-creating-and-styling-an-sem-diagram",
    "href": "sem_overview.html#example-1-creating-and-styling-an-sem-diagram",
    "title": "4  SEM Diagram Functions Overview",
    "section": "4.3 Example 1: Creating and Styling an SEM Diagram",
    "text": "4.3 Example 1: Creating and Styling an SEM Diagram\n\n\n\n\n\nFigure 1. Example 1: Global Settings Modifications in SEM Diagram\n\n\n\n\nThis example walks through generating a basic SEM diagram and applying global aesthetic changes.\nStep 1: Launch and Initial Setup\n\nOpen the ggsem application.\nIn the sidebar, ensure Element Type is set to “SEM Diagram”.\nIn the Lavaan Syntax input box, you will find a pre-loaded example model. You can use this for the demonstration or replace it with your own lavaan syntax.\n\nNote: An SEM can be drawn from the syntax alone; uploading a data file is optional for visualization.\n\n\nStep 2: Generate the Initial Diagram\n\nClick the “Draw a SEM” button. * The app will process your model and display the initial path diagram in the main panel.\n\nStep 3 (Optional): Choose a Layout\n\nBefore or after drawing, you can explore the “SEM Layout Settings” panel\nUse the “Choose Layout Algorithm” dropdown to select a different visual arrangement (e.g., Tree, Circle, Spring) * Advanced Option: The “GenAI” layout is available if you provide a valid API key in the AI settings.\nYou can also flip or rotate the layout globally.\n\nStep 4: Apply Global Node Styles\n\nNavigate to the “Node Settings” panel and open the “Global Settings” section.\nMake the following changes to apply a new color scheme to all nodes: * Latent Node Color: Set to #EDEDED (light gray) * Observed Node Color: Set to #5F98D9 (blue)\n\nStep 5: Apply Global Label Styles\n\nNavigate to the “Annotation Settings” panel and open the “Global Settings” section.\nTo change the text color for all node labels, locate the “Node Labels” controls and set: * Text Color: Set to #000000 (black)\n\nStep 6: Execute the Changes\n\nTo apply all the global aesthetic changes from Steps 4 and 5 to the existing diagram, click the “Apply Changes” button. * The diagram will update instantly, now featuring your new color scheme.",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>SEM Diagram Functions Overview</span>"
    ]
  },
  {
    "objectID": "sem_overview.html#interactive-parameter-control-granular-customization",
    "href": "sem_overview.html#interactive-parameter-control-granular-customization",
    "title": "4  SEM Diagram Functions Overview",
    "section": "4.4 Interactive Parameter Control: Granular Customization",
    "text": "4.4 Interactive Parameter Control: Granular Customization\nFor precise, element-level control, ggsem offers Interactive Parameter Control that transforms your SEM into a dynamic visualization environment.\nDynamic Parameter Selection: A dropdown menu is automatically populated with every free parameter in your model (factor loadings, regressions, covariances, variances).\n\n4.4.1 Granular Element Manipulation:\nNodes:\n\nNodes Aesthetics: Select specific nodes to modify color, size, shape, and border properties\nNodes XY Positions: Fine-tune individual node positions (and associated text labels) with XY coordinate controls\nLatent Group XY Positions: Shift entire latent variable groups as cohesive units\n\nThis shift affects nodes, edge labels, node labels within the selected group.\n\nLatent Group Orientation: Rotate latent groups and their associated observed variables for optimal layout.\n\nThis shift affects nodes, edge labels, node labels within the selected group.\n\n\nEdges:\n\nEdges Aesthetics: Modify specific paths for color, width, style, etc of selected edges\nEdges Curvature: Change the curvature of selected edges\nEdges XY Positions: Precise control over edge start and end points of selected edges\n\nAnnotations:\n\nNode Labels: Modify the text style on selected nodes\nNode Labels XY Positions: Modify the location of text labels on selected nodes\nNode Labels Text: Change the text themselves on selected nodes\nEdge Labels: Modify the text style on edges\nEdge Labels XY Positions: Modify the location of text labels on selected nodes\nEdge Labels Text: Change the text themselves on selected edges\n\nLoop Arrows:\n\nLoop Arrow Aesthetics: Modify the aesthetics of selected self-loop arrows\nLoop Arrow XY Positions: Modify the XY position of selected self-loop arrows\nLoop Removal: Selectively display self-loop arrows to avoid from over-crowding the figure\nLoop Arrow Location: Modify the relative location of the self-loop arrow to node (0-360 degrees), with pre-specified eight direction choices\nLoop Arrow Labels: Modify the text style on selected self-loop arrows\nLoop Label XY Positions: Modify the location of text labels on selected self-loop arrows\nLoop Labels Text: Change the text themselves on selected self-loop arrows\n\nThis granular control system is particularly valuable for exploratory data analysis and creating publication-quality diagrams where every element requires precise styling. Users are encouraged to explore the app on their own to fully learn how these changes work.",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>SEM Diagram Functions Overview</span>"
    ]
  },
  {
    "objectID": "sem_overview.html#example-2-parameter-specific-modifications-in-sem-diagram",
    "href": "sem_overview.html#example-2-parameter-specific-modifications-in-sem-diagram",
    "title": "4  SEM Diagram Functions Overview",
    "section": "4.5 Example 2: Parameter-Specific Modifications in SEM Diagram",
    "text": "4.5 Example 2: Parameter-Specific Modifications in SEM Diagram\nThis example demonstrates how to make granular changes to individual elements of an existing SEM diagram.\nFor this example, download data from https://www.smin95.com/HolzingerSwineford1939.csv, and load it on the ggsem app immediately after launching. Or you can directly load the sample data after launching the app.\n\n\n\n\n\nFigure 2. Example 2: Demonstration of interactive parameter control to perform granular visual transformation\n\n\n\n\nStep 1: Load Your Data and Generate the Diagram\n\nDownload the dataset in CSV format or use pre-loaded sample data (Holzinger & Swinefold) in the app.\nIn the ggsem app, with Element Type set to “SEM Diagram”, upload your CSV file using the “Upload Data” button.\nEnsure your lavaan model syntax is entered in the main text area.\nClick the “Draw a SEM” button to generate the initial diagram with the data.\n\nStep 2: Modify a Specific Node\n\nNavigate to the “Node Settings” panel and find the “Parameter-Specific Modifications” section.\nCheck the box for “Nodes Aesthetics” to expand its menu.\nIn the “Node to Modify” dropdown, select the specific node you wish to change (e.g., x8).\nSet the Node Color to #B5CEE5. This change will only affect the x8 node.\n\nStep 3: Modify a Specific Edge\n\nNavigate to the “Edge Settings” panel and find the “Parameter-Specific Modifications” section.\nCheck the box for “Edges Aesthetics” to expand its menu.\nIn the “Edge to Modify” dropdown, select the specific path you wish to change (e.g., speed to x8).\nSet the following properties: * Edge Color: #91BDC7 * Line Color Type: Single * Note: The “Gradient” option is available to create color-blended paths for further emphasis.\n\nStep 4: Modify a Specific Label\n\nNavigate to the “Annotation Settings” panel and find the “Parameter-Specific Modifications” section.\nCheck the box for “Node Labels Aesthetics” to expand its menu.\nIn the “Node to Modify” dropdown, select the node whose label you wish to change (e.g., x8).\nSet the Text Color to #000000 (black).\n\n** Step 5: Add Self-Loop Arrows to Show Residual**\n\nNavigate to the “Loop Arrows Settings” panel, check the box for “Show Residual Variances, and find the ”Parameter-Specific Modifications”** section.\nCheck the box for “Loop Arrow Aesthetics” to expand its menu.\nIn the “Node to Modify” dropdown, select the node whose label you wish to change (e.g., x8). Set the Line Color to #0F89BA (blue).\nCheck the box for Loop Removal, and remove three loops by choosing nodes in the dropdown (Select loops to remove: visual, textual, speed).\n\nStep 6: Apply All Granular Changes\n21 To execute all the parameter-specific modifications from Steps 2, 3, and 4, click the “Apply Changes” button. * The diagram will update, now highlighting the specific node x8, its connecting edge, and its label with the new colors.\nStep 7: Finalize the Diagram and Test Protection\n\nOnce satisfied with all modifications, click the “Finalize a SEM” button to lock the diagram.\n\n\nNotice the corresponding rows in the output tables now have a green background, indicating they are locked.\n\n\nTo verify the lock is active, try making another aesthetic change (e.g., change the color of node x8 again) and click “Apply Changes”.\n\n\nYou will observe that the diagram no longer changes, confirming that the locked elements are now protected from modifications via the SEM menu. (Locked elements can still be modified using the Aesthetic Grouping menu if needed).",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>SEM Diagram Functions Overview</span>"
    ]
  },
  {
    "objectID": "sem_overview.html#summary-the-sem-visualization-workflow",
    "href": "sem_overview.html#summary-the-sem-visualization-workflow",
    "title": "4  SEM Diagram Functions Overview",
    "section": "4.6 Summary: The SEM Visualization Workflow",
    "text": "4.6 Summary: The SEM Visualization Workflow\nThe ggsem application provides a structured, three-stage workflow for creating, customizing, and finalizing Structural Equation Model diagrams.\nCore Workflow:\n\nGeneration (“Draw a SEM”): Begin by creating an initial diagram from your lavaan syntax, with or without data. The app automatically applies a layout and populates the diagram with statistical estimates, marking all elements as editable.\nCustomization (“Apply Changes”): This is the core interactive phase, where you refine your diagram through two complementary approaches:\n\nGlobal Styling: Apply consistent aesthetic changes to all elements of a type (e.g., color all latent nodes gray).\nParameter-Specific Control: Make granular modifications to individual nodes, edges, and labels for precise, highlight-focused adjustments.\n\nFinalization (“Finalize a SEM”): Lock the diagram to sever the live parametric connection. This protects your work from accidental changes and prepares it for high-quality export, while still allowing advanced edits via the Aesthetic Grouping menu.",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>SEM Diagram Functions Overview</span>"
    ]
  },
  {
    "objectID": "sem_genAI.html",
    "href": "sem_genAI.html",
    "title": "5  AI-Assisted Model and Layout Generations",
    "section": "",
    "text": "5.1 Getting Started: API Configuration\nBefore using AI features, you’ll need to configure API access:",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>AI-Assisted Model and Layout Generations</span>"
    ]
  },
  {
    "objectID": "sem_genAI.html#getting-started-api-configuration",
    "href": "sem_genAI.html#getting-started-api-configuration",
    "title": "5  AI-Assisted Model and Layout Generations",
    "section": "",
    "text": "5.1.1 Step-by-Step Setup:\n\nNavigate to the “Data, Model and AI Specifics” panel in the SEM Diagram section.\nIn the “AI Model” dropdown, select your preferred service:\n\nGoogle Gemini - Excellent for general SEM tasks\nOpenAI GPT - Strong with complex model descriptions\nMistral AI - Balanced performance and efficiency\nAnthropic Claude - Advanced reasoning capabilities\nOllama (Local) - Complete privacy with local processing\n\nConfigure API Settings\n\nFor Cloud Providers (Gemini, OpenAI, Mistral, Claude):\n\nLocate the API key input field that appears after selecting your provider\nObtain your API key from the provider’s developer portal:\n\nGoogle AI Studio: https://aistudio.google.com/\nOpenAI Platform: https://platform.openai.com/api-keys\nMistral Platform: https://console.mistral.ai/\nAnthropic Console: https://console.anthropic.com/\n\nPaste your API key into the input field\n\nFor Ollama (Local):\n\nEnsure Ollama is installed and running on your local machine (ollama serve)\nEnter your preferred local model name (e.g., “llama2”, “mistral”, “codellama”)\nNo API key required for local operation\n\n\nVerify Connection\n\nThe interface will indicate successful API configuration\nTest by generating a simple model to confirm functionality",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>AI-Assisted Model and Layout Generations</span>"
    ]
  },
  {
    "objectID": "sem_genAI.html#two-methods-for-generating-models",
    "href": "sem_genAI.html#two-methods-for-generating-models",
    "title": "5  AI-Assisted Model and Layout Generations",
    "section": "5.2 Two Methods for Generating Models",
    "text": "5.2 Two Methods for Generating Models\n\n5.2.1 Method 1: Generate from Data Structure\nThis approach analyzes your dataset’s patterns to suggest theoretically plausible models. The AI examines correlations and variable relationships to propose appropriate factor structures.\n\n5.2.1.1 Example 1A: Discovering Factor Structure\n\nDownload the demonstration dataset or use pre-loaded sample data (Holzinger & Swinefold) in the app:\n\n\ndemo_data &lt;- read.csv('https://www.smin95.com/HolzingerSwineford1939.csv')\n\n\nIf you have downloaded and uploaded the data in ggsem application, click “Upload Data” and select your CSV file.\nConfigure Parameters:\n\nChoose model type: CFA, Path Analysis, SEM, or Growth\nSet “Maximum Factors” to control model complexity (e.g., 3)\nAdd optional context in “Additional prompts” if needed\n\nExecute: Click “Generate from Data Structure”\n\nSample Output:\nThe AI might generate syntax like:\n# Measurement model for latent factors\n\n# Factor 1: Specific Construct (x4, x5, x6 are highly correlated, suggesting a common underlying construct)\nFactorA =~ x4 + x5 + x6\n\n# Factor 2: Academic Development (ageyr and grade are correlated; agemo is also an age-related measure)\nAcademicDevelopment =~ ageyr + grade + agemo\n\n# Factor 3: Other Measured Items (remaining 'x' variables are grouped into a general factor)\nFactorC =~ x1 + x2 + x3 + x7 + x8 + x9\nNote: Outputs are non-deterministic - your results may vary as the AI explores different plausible structures.\n\n\n\n5.2.2 Method 2: Generate from Natural Language\nDescribe your theoretical model in plain English and let the AI handle the technical syntax conversion.\nExample 1B: Creating a Mediation Model\n\nEnsure the HolzingerSwineford1939 dataset is loaded in the ggsem application (the same CSV file as above).\nIn the “Describe your model in natural language” input, write:\nCreate a structural model where visual ability (x1, x2, x3) influences \ntextual ability (x4, x5, x6) through a mediation of speed ability (x7, x8, x9). \nInclude direct effects from visual to textual and show all factor correlations.\nClick “Generate From Description”. Output will be displayed in the textbox Lavaan Syntax.\n\nSample Output:\n# Measurement model\nvisual_ability =~ x1 + x2 + x3\nspeed_ability =~ x7 + x8 + x9\ntextual_ability =~ x4 + x5 + x6\n\n# Structural model: Visual ability influences Textual ability through Speed ability (mediation)\nspeed_ability ~ visual_ability          # Visual ability predicts Speed ability\ntextual_ability ~ speed_ability         # Speed ability predicts Textual ability\n\n# Include direct effect from Visual ability to Textual ability\ntextual_ability ~ visual_ability        # Direct effect of Visual ability on Textual ability\n\n5.2.2.1 Best Practices for Optimal Results:\nData Preparation (data are optional for Method 2):\n\nUse meaningful variable names (the AI understands common psychological constructs)\nInclude adequate sample size (50+ cases for reliable pattern detection)\nRemove irrelevant columns that might confuse the AI\n\nNatural Language Tips:\n\nBe specific about variable relationships\nUse actual column names from your dataset\nClearly distinguish between measurement and structural models\nSpecify mediation or moderation when relevant\n\n\n\n\n5.2.3 Troubleshooting & Management\n\n5.2.3.1 Common Issues:\n\nAPI Errors: Verify key has sufficient credits and correct permissions\nConnection Problems: Check internet connectivity for cloud providers\nOllama Issues: Ensure service is running with ollama serve\nSyntax Errors: Manually review and correct occasionally invalid syntax\n\n\n\n5.2.3.2 Cost Management:\n\nStart with free tiers (Gemini, OpenAI offer initial credits)\nMonitor usage through your provider’s dashboard\nUse Ollama for unlimited local processing\nFor large projects, estimate costs using provider calculators\n\n\n\n5.2.3.3 Privacy Considerations:\n\nLocal Processing: Ollama keeps all data on your machine\nAPI Policies: Review cloud providers’ data handling policies\nSensitive Data: Use Ollama or anonymize variables before upload\nSession Security: API keys clear when you close the app",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>AI-Assisted Model and Layout Generations</span>"
    ]
  },
  {
    "objectID": "sem_genAI.html#ai-powered-layout-generation",
    "href": "sem_genAI.html#ai-powered-layout-generation",
    "title": "5  AI-Assisted Model and Layout Generations",
    "section": "5.3 AI-Powered Layout Generation",
    "text": "5.3 AI-Powered Layout Generation\nThe GenAI layout feature uses artificial intelligence to automatically generate optimal visual arrangements for your SEM diagrams, potentially creating fresh layouts compared to traditional algorithms.\n\n\n\n\n\nFigure 2. SEM Diagram Generated with Layout Created by GenAI.\n\n\n\n\n\n5.3.0.1 Example 2: Generating an AI-Optimized Layout\nStep 1: Configure API Access\n\nIn the SEM Diagram section, open the “Data, Model and AI Specifics” panel.\nSelect your preferred AI provider (e.g., Google Gemini, OpenAI GPT) from the “AI Model” dropdown.\n\nIn this example, Google Gemini is used because it is free.\n\nEnter your valid API key in the provided field.\nOnce configured, the “GenAI” option will become available in the layout dropdown.\n\nStep 2: Load Your Data and Model\n\nUpload your dataset: Click “Upload Data” and select your CSV file (same as above), or ensure your data is already loaded.\nSpecify your model: Enter or verify your lavaan syntax in the “Lavaan Syntax” input area.\n\nUse either AI-generated or custom lavaan syntax:\nVisual =~ x1 + x2 + x3\nTextual =~ x4 + x5 + x6\nSpeed =~ x7 + x8 + x9\n\n\nStep 3: Generate the GenAI Layout\n\nNavigate to the “SEM Layout Settings” panel.\nFrom the “Choose Layout Algorithm” dropdown, select “GenAI”.\n\nSet Width X and Height Y as 30 (see Figure 2).\n\n(Optional) In the “Additional prompts for layout” text box, you can provide extra context in under 30 words to guide the AI (e.g., “Place the central latent variable at the top”). Note: The app uses optimized default prompts, so additional input is optional.\nClick the “Draw a SEM” button. The AI will generate and render a novel layout for your diagram. Important: GenAI layouts are non-deterministic. Running it again will likely produce a different arrangement.\n\nStep 4: Customize the Aesthetics\n\nModify aesthetic settings in the Node Settings, Edge Settings, and Annotation Settings panels to modify colors, shapes, fonts, and other visual properties. * All standard aesthetic controls work identically on GenAI-generated layouts.\n\nStep 5: Apply and Lock Your Customizations\n12. Click the “Apply Changes” button to update the diagram with your new aesthetics. * This action preserves the GenAI-generated layout and only modifies the visual styles. It does not trigger a re-creation of the layout.\n\nOnce satisfied, click “Finalize a SEM” to lock the diagram and prevent further changes to the layout and aesthetics via the SEM menu.\n\n\n\n5.3.1 Key Features of GenAI Layout:\n\nNon-deterministic: Each generation may produce different but equally valid layouts\nContext-aware: AI considers variable names and model structure\nOptimized spacing: Automatically balances element placement and connection clarity",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>AI-Assisted Model and Layout Generations</span>"
    ]
  },
  {
    "objectID": "sem_stats.html",
    "href": "sem_stats.html",
    "title": "6  Visualize Statistics",
    "section": "",
    "text": "6.1 Parameter Estimates and Annotations\nggsem automatically annotates your path diagrams with statistical estimates, providing immediate insight into your model’s parameters and their significance.",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Visualize Statistics</span>"
    ]
  },
  {
    "objectID": "sem_stats.html#sec-parameter-estimates-and-annotations",
    "href": "sem_stats.html#sec-parameter-estimates-and-annotations",
    "title": "6  Visualize Statistics",
    "section": "",
    "text": "6.1.1 Example 1: Displaying Parameter Estimates\n\nLoad the demonstration dataset in the ggsem app from:\nhttps://www.smin95.com/HolzingerSwineford1939.csv\nOr use pre-loaded sample data (Holzinger & Swinefold) in the app.\nSpecify a CFA model in the lavaan syntax text box.\nVisual =~ x1 + x2 + x3\nTextual =~ x4 + x5 + x6\nSpeed =~ x7 + x8 + x9\nIn the “SEM Statistics” panel, check “Annotate Parameter Estimates”\nConfigure display options:\n\n✅ Unstandardized estimates (default: shown)\n□ Standardized estimates\n□ Confidence intervals\n□ P-values (*)\n\nClick “Draw a SEM” to generate the diagram with statistical annotations\n\n\n\n6.1.2 Customizing Display:\n\nStandardized estimates: Useful for comparing effects across different scales\nConfidence intervals: Shows 95% confidence ranges for parameter estimates\nStatistical-Significance (*): Displays asterisks () indicating statistical significance (p &lt; 0.05). For Bayesian SEM, it displays Bayesian Significance (*) based on whether credible intervals exclude 0.\n\n\n\n6.1.3 Significance Highlighting\nAutomatically emphasize statistically significant paths in your diagram for quick interpretation.\n\nWith your model loaded, check “Highlight Significant Paths (Per Group)”\nConfigure highlighting options:\n\nSignificant Path Color: #C79665 (brown)\nNon-Significant Path Color: #CCCCCC (light gray)\nSignificant Label Fontface: plain\nNon-Significant Label Fontface: plain\n\nClick “Apply Changes” to update the visualization\n\nSignificant paths and edge labels (p &lt; 0.05) will appear in red\n\n(Optional) Modify the aesthetics of latent nodes into dark green and observed nodes into light green to make them more harmonious with the aesthetics of the paths.\n\nLatent nodes color: #307e4f (dark green)\nObserved nodes color: #c8e6e8 (light green)\nNode label color on observed nodes: #000000 (black)\nClick “Apply changes” to update the visualization.",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Visualize Statistics</span>"
    ]
  },
  {
    "objectID": "sem_stats.html#sec-model-fit-assessment",
    "href": "sem_stats.html#sec-model-fit-assessment",
    "title": "6  Visualize Statistics",
    "section": "6.2 Model Fit Assessment",
    "text": "6.2 Model Fit Assessment\nEvaluate your model’s overall performance with comprehensive fit statistics, which are activated after a SEM diagram with a specific model has been drawn using “Draw a SEM” button.\n\nCheck “Display Fit Indices” in the SEM Statistics panel\nSelect desired fit measures:\n\n✅ χ² (Chi-square test of model fit)\n✅ CFI/TLI (Comparative/Tucker-Lewis Fit Index)\n✅ RMSEA (Root Mean Square Error of Approximation with 90% CI)\n□ SRMR (Standardized Root Mean Square Residual)\n\nClick “Apply Changes” to view fit statistics\n\nResults appear in the fit statistics output panel\nCommonly used cutoffs: CFI &gt; 0.90, TLI &gt; 0.90, RMSEA &lt; 0.08\n\n\nSample Output:\nModel Fit Statistics:\nχ²(24) = 85.305, p &lt; .001\nCFI = 0.931, TLI = 0.896\nRMSEA = 0.092, 90% CI [0.071, 0.114]",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Visualize Statistics</span>"
    ]
  },
  {
    "objectID": "sem_stats.html#sec-interactive-parameter-modification",
    "href": "sem_stats.html#sec-interactive-parameter-modification",
    "title": "6  Visualize Statistics",
    "section": "6.3 Interactive Parameter Modification",
    "text": "6.3 Interactive Parameter Modification\n\n\n\n\n\nFigure 2. Interative parameter modification of a model followed by visualization update.\n\n\n\n\nTest theoretical constraints and conduct “what-if” analyses by directly modifying parameter values.\n\n6.3.1 Example 2: Fixing and Testing Parameters, and Updating the Visualization Output\nHere, we are continuing from Example 1 using the same dataset.\n\nCheck “Interactive Parameter Modification (Fix)”\nSelect a parameter from the dropdown (e.g., “Visual =~ x2”)\nSet a new value in “New Unstandardized Value” (e.g., 1.0)\n(Optional) Check the box “P-values (*)“, it will display asterisks for statistically significant paths\n(Optional) Configure highlighting options:\n\nSignificant Path Color: #C79665 (brown)\nNon-Significant Path Color: #CCCCCC (light gray)\nSignificant Label Fontface: bold\nNon-Significant Label Fontface: plain\n\nClick “Modify Parameter” then “Apply Changes” to update the visualization\n\nNote that the path between visual node and x2 node is no longer significant, and its parameter value updates to 1\n\n\n\n6.3.1.1 What happens:\n\nThe selected parameter is fixed to your specified value\nAll other parameters are re-estimated conditional on this constraint\nFit statistics update to reflect the constrained model\nVisualization is updated with the modified parameter estimate after clicking “Apply Changes”.",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Visualize Statistics</span>"
    ]
  },
  {
    "objectID": "sem_stats.html#model-comparison-tests",
    "href": "sem_stats.html#model-comparison-tests",
    "title": "6  Visualize Statistics",
    "section": "6.4 Model Comparison Tests",
    "text": "6.4 Model Comparison Tests\nCompare nested models using likelihood ratio tests to evaluate which model is better.\n\nYour baseline model is saved when you generate a SEM diagram by clicking “Draw a SEM”.\n\nThis is your initial SEM with all parameters free\nNote the fit statistics (χ², CFI, RMSEA)\n\nCreate a constrained model by fixing a parameter in “Interactive Parameter Modification (Fix)”(e.g., set “Visual =~ x2” to 1.0).\n\nApply changes and note the new fit statistics\n\nCheck “Model Comparisons” to view likelihood ratio test results\n\nSample Output:\nLIKELIHOOD RATIO TEST\n=====================\n\nMODEL COMPARISON:\n• Original Model: All parameters free\n• Constrained Model: Parameter(s) fixed\n\nTEST RESULTS:\n-------------\nChi-square difference:   -0.000\nDegrees of freedom:           1\np-value:                 1.0000\nRMSEA:                   0.0000\n\nMODEL FIT INDICES:\n------------------\nOriginal Model AIC:    7517.5\nConstrained Model AIC:   7515.5\nOriginal Model BIC:    7595.3\nConstrained Model BIC:   7589.6\n\nINTERPRETATION:\n---------------\n✓ NO significant difference (p &gt;= 0.05)\n→ The constraint does not worsen model fit\n→ The constraint may be reasonable\nInterpretation:\n\nSignificant χ² difference (p &lt; 0.05) suggests the constraint worsens model fit\nNon-significant difference suggests the constraint is empirically supported\n\nComplete Statistical Analysis:\n\nLoad data and specify your theoretical model\nDraw initial SEM with unstandardized estimates and fit indices\nReview significance: Use highlighting to identify significant paths with specific aesthetics\nAssess fit: Check if CFI &gt; 0.90, RMSEA &lt; 0.08 for acceptable fit\nTest constraints: Use parameter modification to test theoretical constraints\nCompare models: Use likelihood ratio tests for nested model comparisons\nFinalize: Lock the diagram with optimal parameterization",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Visualize Statistics</span>"
    ]
  },
  {
    "objectID": "sem_stats.html#multi-group-analysis",
    "href": "sem_stats.html#multi-group-analysis",
    "title": "6  Visualize Statistics",
    "section": "6.5 Multi-Group Analysis",
    "text": "6.5 Multi-Group Analysis\nggsem also provides options for users to explore multi-group SEM analysis. It highlights paths that are group-specific or constrained across groups (Highlight Multi-Group Invariance), as well as statistically different paths between groups (Highlight Group Differences). This only works when two SEMs have been drawn with a single multi-group model. Interested readers can continue to the next chapter (code-free) to learn how to plot multi-group SEM visualizations or other subsequent chapters (code-based).",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Visualize Statistics</span>"
    ]
  },
  {
    "objectID": "sem_multigroup.html",
    "href": "sem_multigroup.html",
    "title": "7  Multi-Group SEM Visualization",
    "section": "",
    "text": "7.1 Setting Up Multi-Group Analysis\nFigure 1. Visualizing Multi-Group Data in SEM",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Multi-Group SEM Visualization</span>"
    ]
  },
  {
    "objectID": "sem_multigroup.html#setting-up-multi-group-analysis",
    "href": "sem_multigroup.html#setting-up-multi-group-analysis",
    "title": "7  Multi-Group SEM Visualization",
    "section": "",
    "text": "7.1.1 Example: Creating Multiple SEMs from Multi-Group Data\nThis example demonstrates how to visualize a SEM diagram for just one group (e.g., Pasteur school) from a multi-group dataset, using the group management system to isolate and customize specific groups.\nStep 1: Load Your Data and Model\n\nDownload data (CSV format) from online and upload it in the app\nhttps://www.smin95.com/HolzingerSwineford1939.csv\n\n\ndemo_data &lt;- read.csv('https://www.smin95.com/HolzingerSwineford1939.csv')\nhead(demo_data) # first six rows\n\n  id sex ageyr agemo  school grade       x1   x2    x3       x4   x5        x6\n1  1   1    13     1 Pasteur     7 3.333333 7.75 0.375 2.333333 5.75 1.2857143\n2  2   2    13     7 Pasteur     7 5.333333 5.25 2.125 1.666667 3.00 1.2857143\n3  3   2    13     1 Pasteur     7 4.500000 5.25 1.875 1.000000 1.75 0.4285714\n4  4   1    13     2 Pasteur     7 5.333333 7.75 3.000 2.666667 4.50 2.4285714\n5  5   2    12     2 Pasteur     7 4.833333 4.75 0.875 2.666667 4.00 2.5714286\n6  6   2    14     1 Pasteur     7 5.333333 5.00 2.250 1.000000 3.00 0.8571429\n        x7   x8       x9\n1 3.391304 5.75 6.361111\n2 3.782609 6.25 7.916667\n3 3.260870 3.90 4.416667\n4 3.000000 5.30 4.861111\n5 3.695652 6.30 5.916667\n6 4.347826 6.65 7.500000\n\ntail(demo_data) # last six rows\n\n     id sex ageyr agemo      school grade       x1   x2    x3       x4   x5\n296 345   1    13     3 Grant-White     8 6.166667 6.50 3.000 3.000000 4.25\n297 346   1    13     5 Grant-White     8 4.000000 7.00 1.375 2.666667 4.25\n298 347   2    14    10 Grant-White     8 3.000000 6.00 1.625 2.333333 4.00\n299 348   2    14     3 Grant-White     8 4.666667 5.50 1.875 3.666667 5.75\n300 349   1    14     2 Grant-White     8 4.333333 6.75 0.500 3.666667 4.50\n301 351   1    13     5 Grant-White    NA 4.333333 6.00 3.375 3.666667 5.75\n          x6       x7   x8       x9\n296 2.857143 3.043478 4.25 5.666667\n297 1.000000 5.086957 5.60 5.250000\n298 1.000000 4.608696 6.05 6.083333\n299 4.285714 4.000000 6.00 7.611111\n300 2.000000 5.086957 6.20 4.388889\n301 3.142857 4.086957 6.95 5.166667\n\n\nNote that this dataset contains a column containing identifer for different levels of variables.\n\nSpecify your multi-group model in lavaan syntax:\nVisual =~ x1 + x2 + x3\nTextual =~ x4 + x5 + x6\nSpeed =~ x7 + x8 + x9\n\nStep 2: Configure Multi-Group Settings\n\nCheck the box for “Multi-Group Data” to enable group-specific analysis\nGrouping Variable refers to the column name in your uploaded dataset. The dropdown gets updated accordingly with available columns.\n\n\nSelect: Grouping Variable: school\n\n\nGroup Level refers to each level in the selected Grouping Variable. The dropdown gets updated accordingly.\n\n\nSelect: Group Level: Pasteur\n\nStep 3: Set Model Constraints and Layout\n\nThree types of model fitting are available with different levels of model constraints\n\n\nSelect your preferred invariance level (configural, metric, or scalar).\nUse results from multi-group model comparisons to determine which model should be visualized:\n\nCheck model fit statistics to ensure your chosen invariance level is appropriate\nIf metric invariance holds, you might constrain loadings across groups\nIf invariance fails, you may need to keep parameters free for each group\n\n\n\nChoose Tree2 for SEM layout in the Layout Settings panel\nChange its location so that its Center X is -35\nIntercept nodes are visualized by default for multi-group data (can be toggled off if desired by unchecking the box)\n\nStep 4: Generate and Identify the Diagram\n\nClick “Draw a SEM” to generate the first group’s diagram\nThe SEM diagram that you will generate will have its group id assigned as 1\n\n\nNotice that its group id is set as “1” as we specified before in Assign Group in the Output Tables’ Group Column\n\nStep 5: Create a Second Group Diagram\n\n\n\n\n\nFigure 2. Create a Second Diagram\n\n\n\n\n\nChange the Group Level from “Pasteur” to “Grant-White”\nCheck if the Assign Group input is “2” to for a new group ID (it should be set automatically).\nChange its location so that its Center X is +35\nClick “Draw a SEM” again to generate the second group’s diagram\n\nThe new diagram will be created with group ID “2”\nBoth diagrams now exist in the same workspace with different group identifiers\n\n\nStep 6: Manage Group-Specific Modifications\n\nYou can selectively modify elements from one group but not another\n\n\nUse the “Which Group to Modify” dropdown to ensure you’re editing group “1” (Pasteur)\nApply visual customizations that will only affect this specific group\nWith “1” group selected:\n\nSelect its group ID (“1”) in Which Group to Modify dropdown.\nModify the global settings of node aesthetics (check the box All Nodes):\n\nSet Latent Node Color to #CD6B5B (red)\nSet Observed Node Color to #3E7671 (green)\nSet Intercept Node Color to #887E6D (brown)\nOr in Choose Color Palette dropdown, choose Earth Tones\n\nClick “Apply Changes”\n\nFor Group “2” (Grant-White):\n\nSelect its group ID (“2”) in Which Group to Modify dropdown\nModify the global settings of node aesthetics (check the box All Nodes):\n\nSet latent node color to #4E79A7 (blue)\nSet observed node color to #F28E2B (orange)\nSet intercept node color to #59A14F (green)\nOr in Choose Color Palette dropdown, choose Vibrant Primary\n\nClick “Apply Changes”\n\n\nNow, you have two SEM diagrams side-by-side.\n\n\n\n\n\nFigure 3. Final output: two SEM diagrams side-by-side from one model\n\n\n\n\n\n7.1.1.1 Group Management and Navigation\nSwitching Between Groups:\n\nUse the “Group Level” dropdown to switch between different groups (e.g., Pasteur vs. Grant-White schools)\nEach group maintains its own aesthetic settings and modifications\nYou can create second SEM with Grant-White school level with different group ID, and explore how Apply Changes uses group label to modify each group’s elements.\n\nGroup Assignment System:\n\n“Which Group to Modify”: Select which group’s elements you want to edit\n“Assign Group”: Set group labels for newly added elements (default: “1”)",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Multi-Group SEM Visualization</span>"
    ]
  },
  {
    "objectID": "sem_multigroup.html#intercept-visualization",
    "href": "sem_multigroup.html#intercept-visualization",
    "title": "7  Multi-Group SEM Visualization",
    "section": "7.2 Intercept Visualization",
    "text": "7.2 Intercept Visualization\nMulti-group analysis includes options for displaying intercept terms:\n\nCheck “Show intercept nodes” to visualize intercept parameters\nIntercept nodes appear as triangles in the diagram\nUseful for understanding mean structure differences between groups",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Multi-Group SEM Visualization</span>"
    ]
  },
  {
    "objectID": "sem_multigroup.html#practical-workflow-example",
    "href": "sem_multigroup.html#practical-workflow-example",
    "title": "7  Multi-Group SEM Visualization",
    "section": "7.3 Practical Workflow Example",
    "text": "7.3 Practical Workflow Example\nComplete Multi-Group Analysis:\n\nLoad data with grouping variable (e.g., school, gender, treatment condition)\nAfter checking the box Multi-Group Data, check the Grouping Variable (e.g., school) and plot multi-group SEM diagrams.\nExplore configural, metric and scale invariance.\nCompare groups visually by highlighting significantly different paths between groups (Highlight Group Differences) or group-specific differences or invariance (Highlight Multi-Group Invariance).\nExamine modification indices for sources of misfit\nUse Interactive Parameter Visualization to further modify aesthetics.\n\nThis is an example of what multi-group SEM visualization output could look like with ggsem. Red paths are significantly different paths between two groups. Purple paths represent where estimated parameters are constrained to be equal between groups, while brown paths denote where estimated parameters are group-specific (hence, different between groups). These can all be highlighted automatically in ggsem.\n\n\n\n\n\nFigure 4. Final output: two SEM diagrams side-by-side from one model with paths highlighted",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Multi-Group SEM Visualization</span>"
    ]
  },
  {
    "objectID": "sem_multigroup.html#group-specific-customization",
    "href": "sem_multigroup.html#group-specific-customization",
    "title": "7  Multi-Group SEM Visualization",
    "section": "7.4 Group-Specific Customization",
    "text": "7.4 Group-Specific Customization\nEach group maintains independent aesthetic settings:\n\nNode colors, sizes, and shapes can vary by group\nEdge properties (colors, widths, styles) are group-specific\nLabel formatting can be customized per group\nLayout adjustments can be made separately for each group",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Multi-Group SEM Visualization</span>"
    ]
  },
  {
    "objectID": "sem_multigroup.html#summary-multi-group-sem-visualization",
    "href": "sem_multigroup.html#summary-multi-group-sem-visualization",
    "title": "7  Multi-Group SEM Visualization",
    "section": "7.5 Summary: Multi-Group SEM Visualization",
    "text": "7.5 Summary: Multi-Group SEM Visualization\nThe multi-group functionality enables analysis of structural equation models across different population subgroups within a single dataset. Users can specify a grouping variable from their data and select individual group levels to visualize. Each group is assigned a unique identifier that allows for independent customization of visual properties including node colors, sizes, and layout preferences.\nThe system supports configural, metric, and scalar invariance testing to examine whether model parameters remain consistent across groups. Users can generate separate diagrams for different groups while maintaining them in the same workspace, facilitating visual comparison of model structures and parameter estimates across populations. This approach provides a method for examining measurement invariance and group differences while maintaining consistent model specification across subgroups.",
    "crumbs": [
      "Code-free SEM Visualization",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Multi-Group SEM Visualization</span>"
    ]
  },
  {
    "objectID": "network_overview.html",
    "href": "network_overview.html",
    "title": "8  Network Diagram Functions Overview",
    "section": "",
    "text": "8.1 Data Specification & Input\nFigure 1. Network Data Input: Users can upload edge list data and configure network layout settings.\nggsem accepts CSV files in edge list format for network visualization, providing flexible options for both weighted and unweighted networks.\nEdge List Format:\nWith edge weights:\nWithout edge weights:\nColumn specifications:\nExample Data Preparation:\n# Download and examine example network data\n(edges_data &lt;- read.csv('https://www.smin95.com/edges_example.csv'))\n\n   source target weight\n1       A      E      1\n2       B      A      1\n3       C      B      2\n4       C      G      1\n5       D      C      1\n6       E      D      2\n7       E      F      1\n8       F      A      1\n9       G      H      2\n10      H      D      1",
    "crumbs": [
      "Code-free Network Visualization",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Network Diagram Functions Overview</span>"
    ]
  },
  {
    "objectID": "network_overview.html#data-specification-input",
    "href": "network_overview.html#data-specification-input",
    "title": "8  Network Diagram Functions Overview",
    "section": "",
    "text": "source,target,weight\nA,B,1.0\nA,C,2.0\nB,C,3.0\nC,D,1.5\n\nsource,target\nA,B\nA,C\nB,C\nC,D\n\n\nsource: Node where edges originate\ntarget: Node where edges arrive\nweight (optional): Strength of connection between nodes",
    "crumbs": [
      "Code-free Network Visualization",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Network Diagram Functions Overview</span>"
    ]
  },
  {
    "objectID": "network_overview.html#layout-algorithms-and-network-configuration",
    "href": "network_overview.html#layout-algorithms-and-network-configuration",
    "title": "8  Network Diagram Functions Overview",
    "section": "8.2 Layout Algorithms and Network Configuration",
    "text": "8.2 Layout Algorithms and Network Configuration\nggsem supports multiple layout algorithms for optimal network visualization:\nTraditional Layouts (directly affected by Random Seed):\n\nFruchterman-Reingold: Force-directed layout emphasizing edge length uniformity\nKamada-Kawai: Force-directed layout based on graph distances\nCircular: Nodes arranged in circle pattern\nGrid: Regular grid arrangement\nRandom: Stochastic node placement (see below)\n\nAdvanced Layouts:\n\nDimensionality Reduction: Machine learning approaches including t-SNE, UMAP, and PCA\nGenAI: AI-powered layout optimization (requires API configuration; see next chapter)\n\nNetwork Configuration Options:\n\nDirected/Undirected: Toggle directed edge visualization\nRandom Seed: Ensure reproducible layouts\nClustering: Enable community detection with multiple algorithms (Louvain, Leiden, Walktrap, Fast Greedy)\nCluster Coloring: 10 color palettes for community visualization",
    "crumbs": [
      "Code-free Network Visualization",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Network Diagram Functions Overview</span>"
    ]
  },
  {
    "objectID": "network_overview.html#the-interactive-workflow-cycle",
    "href": "network_overview.html#the-interactive-workflow-cycle",
    "title": "8  Network Diagram Functions Overview",
    "section": "8.3 The Interactive Workflow Cycle",
    "text": "8.3 The Interactive Workflow Cycle\nggsem operates on a three-stage workflow for network visualization, maintaining clear separation between data import, customization, and finalization.\nStage 1: “Draw a Network” - Initial Generation\nClick the “Draw a Network” button to generate the initial diagram from your edge list data with several features:\n\nAutomatic Layout: Applies your chosen layout algorithm to create an optimized network structure\nElement Integration: Creates nodes, edges, and automatic labels based on your data\nEditable State: All generated elements are marked with network = TRUE in output tables, ready for modification\n\nStage 2: “Apply Changes” - Visual Editing Over Network Elements\nThis stage focuses on applying visual customizations across your network. When you press “Apply Changes”, ggsem performs comprehensive updates while maintaining data integrity.\nA. Global Node Settings\nApply consistent styling across all nodes:\n\nShape Customization: Circle, square, rectangle, oval, triangle, and diamond shapes\nSize & Color Control: Independent adjustments to node sizes, colors, border properties\nLabel Formatting: Text properties for all node labels\n\nB. Global Edge Settings\nStandardize the appearance of all connections:\n\nLine Properties: Color, width, transparency, and style controls\nWeight Scaling: Scale edge width by weight values with customizable min/max ranges\nCurvature Control: Automatic or manual edge curvature for better visibility\nArrow/Edge Customization: Direction indicators for directed networks\n\nC. Global Annotation Settings\nMaintain consistent text formatting:\n\nNode Labels: Font family, size, color, and positioning\nEdge Labels: Automatic weight display with formatting options\nText Properties: Comprehensive text customization controls\n\nStage 3: “Finalize a Network” - Network Options Lock\n\nEdit Protection: Changes network column to FALSE in output tables, making elements immune to further “Apply Changes” operations\nVisual Preservation: Locks current layout and styling while allowing export\nExport Preparation: Optimizes the diagram for publication output",
    "crumbs": [
      "Code-free Network Visualization",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Network Diagram Functions Overview</span>"
    ]
  },
  {
    "objectID": "network_overview.html#example-1-creating-and-styling-a-basic-network-diagram",
    "href": "network_overview.html#example-1-creating-and-styling-a-basic-network-diagram",
    "title": "8  Network Diagram Functions Overview",
    "section": "8.4 Example 1: Creating and Styling a Basic Network Diagram",
    "text": "8.4 Example 1: Creating and Styling a Basic Network Diagram\n\n\n\n\n\nFigure 2. Example 1: Global Settings Modifications in Network Diagram\n\n\n\n\nThis example walks through generating a basic network diagram and applying global aesthetic changes.\nStep 1: Data Preparation and Upload\n\nDownload example edge list data: https://www.smin95.com/edges_example.csv\nIn ggsem, select “Network Diagram” from Element Type dropdown\nUpload your CSV file using the “Upload Network CSV File” button\n\nStep 2: Configure Layout Settings\n\nNavigate to “Network Layout Settings” panel\nSet random seed to 123 for reproducible layout\nChoose Fruchterman-Reingold layout algorithm\nAdjust layout dimensions as needed (Layout Width (X) = 35, Layout Height (Y) = 35)\n\nStep 3: Generate Initial Diagram\n\nClick the “Draw a Network” button\nThe app will process your data and display the initial network diagram\n\nStep 4: Apply Global Node Styles\n\nNavigate to “Node Settings” panel and open “Nodes Aesthetics” under “Global Settings”\nMake the following changes:\n\n\nNode Color: Set to `#AB5250` (red)\nNode Size: Set to 15\n\nStep 5: Apply Global Edge Styles\n\nNavigate to “Edge Settings” panel\nConfigure edge properties by opening “Edge Aesthetics” under “Global Settings”\n\n\nEdge Color: Set to #79706E (gray)\nEdge Width: Set to 1.5\nEnable “Scale Edge Width by Weight” with min = 1.0, max = 2.5\n\nStep 6: Execute Changes\n\nClick the “Apply Changes” button\nThe diagram updates with new color scheme and weight-scaled edges",
    "crumbs": [
      "Code-free Network Visualization",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Network Diagram Functions Overview</span>"
    ]
  },
  {
    "objectID": "network_overview.html#interactive-parameter-control-granular-customization",
    "href": "network_overview.html#interactive-parameter-control-granular-customization",
    "title": "8  Network Diagram Functions Overview",
    "section": "8.5 Interactive Parameter Control: Granular Customization",
    "text": "8.5 Interactive Parameter Control: Granular Customization\nFor precise, element-level control, ggsem offers Interactive Parameter Control that transforms your network into a dynamic visualization environment.\nDynamic Element Selection: Dropdown menus automatically populate with all nodes, edges, and labels from your network data.\nGranular Element Manipulation:\n\n8.5.1 Granular Element Manipulation:\nNodes:\n\nNodes Aesthetics: Select specific nodes to modify color, size, shape, and border properties\nNodes XY Positions: Fine-tune individual node positions (and associated text labels) with XY coordinate controls\n\nEdges:\n\nEdges Aesthetics: Modify specific paths for color, width, style, etc of selected edges\nEdges Curvature: Change the curvature of selected edges\nEdges XY Positions: Precise control over edge start and end points of selected edges\n\nAnnotations:\n\nNode Labels: Modify the text style on selected nodes\nNode Labels XY Positions: Modify the location of text labels on selected nodes\nNode Labels Text: Change the text themselves on selected nodes\nEdge Labels: Modify the text style on edges\nEdge Labels XY Positions: Modify the location of text labels on selected nodes\nEdge Labels Text: Change the text themselves on selected edges",
    "crumbs": [
      "Code-free Network Visualization",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Network Diagram Functions Overview</span>"
    ]
  },
  {
    "objectID": "network_overview.html#example-2-parameter-specific-modifications-in-network-diagram",
    "href": "network_overview.html#example-2-parameter-specific-modifications-in-network-diagram",
    "title": "8  Network Diagram Functions Overview",
    "section": "8.6 Example 2: Parameter-Specific Modifications in Network Diagram",
    "text": "8.6 Example 2: Parameter-Specific Modifications in Network Diagram\n\n\n\n\n\nFigure 3. Example 2: Interactive parameter control for granular network customization\n\n\n\n\nThis example demonstrates how to make granular changes to individual elements of an existing network diagram.\nStep 1: Load Data and Generate Diagram\n\nDownload dataset: https://www.smin95.com/edges_example.csv\nNavigate to “Network Layout Settings” panel\nSet random seed to `57629`for reproducible layout\nChoose Fruchterman-Reingold layout algorithm\nAdjust layout dimensions as needed (Layout Width (X) = 35, Layout Height (Y) = 35)\nUpload CSV file and click “Draw a Network”\n\nStep 2: Modify Specific Nodes\n\nIn “Node Settings”, check “Nodes Aesthetics” under Parameter-Specific Modifications\nSelect “Node A” from the “Node to Modify” dropdown\nSet Node Color to #D97357 (orange) and Node Size to 15 (default)\n\nStep 3: Modify Specific Edges\n\nIn “Edge Settings”, check “Edges Aesthetics”\nSelect “A to B” from the “Edge to Modify” dropdown\nSet Edge Color to #9C2C2A (dark red) and Line Width to 2.0\n\nStep 4: Modify Specific Labels\n\nIn “Annotation Settings”, check “Node Labels Aesthetics”\nSelect “Node A” label and set Text Color to #FFFFFF (white) and Text Size to 20\n\nStep 5: Apply All Granular Changes\n\nClick “Apply Changes” to update the selected elements\nThe diagram highlights specific nodes, edges, and labels with custom styling\n\nStep 6: Finalize Diagram\n\nClick “Finalize a Network” to lock the diagram\nVerify protection by attempting additional modifications",
    "crumbs": [
      "Code-free Network Visualization",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Network Diagram Functions Overview</span>"
    ]
  },
  {
    "objectID": "network_overview.html#summary-the-network-visualization-workflow",
    "href": "network_overview.html#summary-the-network-visualization-workflow",
    "title": "8  Network Diagram Functions Overview",
    "section": "8.7 Summary: The Network Visualization Workflow",
    "text": "8.7 Summary: The Network Visualization Workflow\nThe ggsem application provides a structured, three-stage workflow for creating, customizing, and finalizing network diagrams.\nCore Workflow:\n\nGeneration (“Draw a Network”): Create initial diagram from edge list data with automatic layout optimization\nCustomization (“Apply Changes”): Refine your diagram through global styling and parameter-specific controls for individual elements\nFinalization (“Finalize a Network”): Lock the diagram to protect against accidental changes while maintaining export capabilities",
    "crumbs": [
      "Code-free Network Visualization",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Network Diagram Functions Overview</span>"
    ]
  },
  {
    "objectID": "network_genAI.html",
    "href": "network_genAI.html",
    "title": "9  AI-Powered Network Layout Generation",
    "section": "",
    "text": "9.1 Getting Started: API Configuration\nFigure 1. Setting GenAI options for generating network layout.\nBefore using AI features for network layout generation, you’ll need to configure API access:",
    "crumbs": [
      "Code-free Network Visualization",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>AI-Powered Network Layout Generation</span>"
    ]
  },
  {
    "objectID": "network_genAI.html#getting-started-api-configuration",
    "href": "network_genAI.html#getting-started-api-configuration",
    "title": "9  AI-Powered Network Layout Generation",
    "section": "",
    "text": "9.1.1 Step-by-Step Setup:\n\nNavigate to the “Data, Model and AI Specifics” panel in the SEM Diagram section.\nIn the “AI Model” dropdown, select your preferred service:\n\nGoogle Gemini - Excellent for general SEM tasks\nOpenAI GPT - Strong with complex model descriptions\nMistral AI - Balanced performance and efficiency\nAnthropic Claude - Advanced reasoning capabilities\nOllama (Local) - Complete privacy with local processing\n\nConfigure API Settings\n\nFor Cloud Providers (Gemini, OpenAI, Mistral, Claude):\n\nLocate the API key input field that appears after selecting your provider\nObtain your API key from the provider’s developer portal:\n\nGoogle AI Studio: https://aistudio.google.com/\nOpenAI Platform: https://platform.openai.com/api-keys\nMistral Platform: https://console.mistral.ai/\nAnthropic Console: https://console.anthropic.com/\n\nPaste your API key into the input field\n\nFor Ollama (Local):\n\nEnsure Ollama is installed and running on your local machine (ollama serve)\nEnter your preferred local model name (e.g., “llama2”, “mistral”, “codellama”)\nNo API key required for local operation\n\n\nVerify Connection\n\nThe interface will indicate successful API configuration\nTest by generating a simple model to confirm functionality",
    "crumbs": [
      "Code-free Network Visualization",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>AI-Powered Network Layout Generation</span>"
    ]
  },
  {
    "objectID": "network_genAI.html#ai-powered-layout-generation",
    "href": "network_genAI.html#ai-powered-layout-generation",
    "title": "9  AI-Powered Network Layout Generation",
    "section": "9.2 AI-Powered Layout Generation",
    "text": "9.2 AI-Powered Layout Generation\nThe GenAI feature automatically generates fresh layouts for your network diagrams.\n\n\n\n\n\nFigure 2. SEM Diagram Generated with Layout Created by GenAI.\n\n\n\n\n\n9.2.0.1 Example 1: Generating an AI-Optimized Layout\nStep 1: Configure API Access\n\nIn the SEM Diagram section, open the “Data, Model and AI Specifics” panel.\nSelect your preferred AI provider from the “AI Model” dropdown.\n\nIn this example, Google Gemini is used because it is free.\n\nEnter your valid API key in the provided field.\nOnce configured, the “GenAI” option will become available in the layout dropdown in Network Diagram menu.\n\nStep 2: Generate the Network Layout\n\nNavigate to the “Network Layout Settings” panel.\nFrom the “Choose Layout Algorithm” dropdown, select “GenAI”.\n\nSet Layout Width (X) and Layout Height (Y) as 35 (see Figure 2).\nSet random seed as 14324 for reproducibility\n\n(Optional) In the “Additional prompts for layout” text box, provide brief context to guide the AI (under 30 words).\nClick the “Draw a Network” button.\n\nThe AI generates and displays a novel layout for your network.\nImportant: GenAI layouts are non-deterministic - running again may produce different arrangements\n\n\nStep 3: Customize the Aesthetics\n\nUse Node Settings,Edge Settings, and Annotation Settings panels to modify:\n\nColors, shapes, and sizes\nFont properties and label positioning\nEdge styles and curvature\nAll standard aesthetic controls function with GenAI-generated layouts\n\n\nStep 4: Apply and Lock Your Customizations\n\nClick “Apply Changes” to update the diagram with new aesthetics\n\nThis preserves the GenAI layout while modifying visual styles\nDoes not trigger layout re-generation\n\nClick “Finalize a Network” to lock the diagram\n\nPrevents further changes to layout and aesthetics via Network menu\nMaintains the AI-optimized arrangement\n\n\n\n\n9.2.1 Key Features of GenAI Layout:\n\nNon-deterministic: Different generations may produce varied but valid layouts\nContext-aware: AI considers node names and network structure in layout decisions\nOptimized spacing: Automatically balances node placement and connection clarity\nNovel perspectives: May reveal network patterns not apparent with traditional algorithms",
    "crumbs": [
      "Code-free Network Visualization",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>AI-Powered Network Layout Generation</span>"
    ]
  },
  {
    "objectID": "sem_preload.html",
    "href": "sem_preload.html",
    "title": "10  Integrated SEM Workflow",
    "section": "",
    "text": "Purpose of this workflow:\nIf you want to modify aesthetics using interactive parameter visualization (dynamic dropdown of all nodes and edges etc), then you should pre-load output objects from other packages into ggsem.\nFigure 0. Interactive parameter visualization: Interactively modify the aesthetics of parameter ‘textual’ node through a dynamic dropdown",
    "crumbs": [
      "Single-Group Workflow Using Pre-loaded Objects",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Integrated SEM Workflow</span>"
    ]
  },
  {
    "objectID": "sem_preload.html#loading-lavaan-objects",
    "href": "sem_preload.html#loading-lavaan-objects",
    "title": "10  Integrated SEM Workflow",
    "section": "1. Loading lavaan Objects",
    "text": "1. Loading lavaan Objects\nYou can directly visualize fitted structural equation models from the lavaan package by passing the fitted object to ggsem().\n\nStep 1: Fit Your SEM Model\nFirst, ensure you have the required packages installed and loaded:\n\nlibrary(ggsem)\nlibrary(lavaan)\nlibrary(semPlot)\nlibrary(blavaan)\nlibrary(lavaanPlot)\n\n\n# Specify and fit a CFA model\nmodel &lt;- '\n  visual  =~ x1 + x2 + x3\n  textual =~ x4 + x5 + x6  \n  speed   =~ x7 + x8 + x9\n'\n\nfit &lt;- sem(model, data = HolzingerSwineford1939)\n\n\n\nStep 2: Launch ggsem with the Fitted Model\nPass the fitted lavaan object to ggsem using the object parameter:\n\n# Launch app with the lavaan model pre-loaded\nggsem(object = fit)\n\n\n\n\n\n\nFigure 1. SEM generated from pre-load lavaan object\n\n\n\n\nImportant: The lavaan object must be provided to the object argument. The model argument is used only when object (visualization output, such as qgraph) is also provided.\n\nWhat Happens When You Load a lavaan Object:\n\nThe SEM diagram is automatically generated and displayed\nAll parameter estimates are pre-calculated and visible\nModel fit statistics are computed and available\nThe original data is preserved for further analysis\nThe diagram is immediately customizable\n\n\n\nCustomizing the Initial Visualization\nYou can control the initial appearance of your lavaan model by specifying additional parameters in the ggsem function call:\n\nggsem(\n  object = fit,\n  center_x = 15,    # X-coordinate for diagram center\n  center_y = 15,    # Y-coordinate for diagram center  \n  width = 40,       # Width of visualization area\n  height = 40       # Height of visualization area\n)\n\n\n\n\n\n\nFigure 2. A larger SEM generated from pre-load lavaan object",
    "crumbs": [
      "Single-Group Workflow Using Pre-loaded Objects",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Integrated SEM Workflow</span>"
    ]
  },
  {
    "objectID": "sem_preload.html#loading-semplot-objects",
    "href": "sem_preload.html#loading-semplot-objects",
    "title": "10  Integrated SEM Workflow",
    "section": "2. Loading semPlot Objects",
    "text": "2. Loading semPlot Objects\nggsem accepts semPlot objects (which inherit from the qgraph class), allowing you to import pre-configured visualizations.\n\nStep 1: Create semPlot Object\n\n# Create semPlot object - this is actually a qgraph object\n\nsemplot_obj &lt;- semPaths(\n  fit, \n  layout = \"tree2\",\n  what = \"paths\",\n  whatLabels = \"est\",\n  style = \"lisrel\",\n  residuals = TRUE\n)\n\n\n\n\n\n\n\nclass(semplot_obj)  # Returns \"qgraph\"\n\n[1] \"qgraph\"\n\n\nIt is always better to set residuals = TRUE in semplot object that is to be pre-loaded to ggsem. If residuals = FALSE, then ggsem will not have access to information about residuals when only semPlot is pre-loaded (option B, see below). However, it can be set to FALSE when you pre-load lavaan model with semPlot object (option A, see below).\n\n\nStep 2: Launch ggsem with qgraph Object\nLoad qgraph object using object argument in ggsem().\n\n# Option A: With full functionality (recommended)\nggsem(object = semplot_obj, model = fit)\n\n# Option B: Visual customization only (limited)\nggsem(object = semplot_obj)\n\n\n\n\n\n\nFigure 3. A SEM generated from pre-load lavaan object and pre-loaded semPlot object\n\n\n\n\nImportant: The object argument must contain the semPaths plot. model argument can contain the original lavaan model for full functionality (optional).\nUnderstanding qgraph Object Limitations: When loading a qgraph object without the original lavaan model, ggsem can only access the visual representation, not the underlying statistical model. Missing edge labels in the original qgraph object will remain missing.",
    "crumbs": [
      "Single-Group Workflow Using Pre-loaded Objects",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Integrated SEM Workflow</span>"
    ]
  },
  {
    "objectID": "sem_preload.html#loading-blavaan-objects",
    "href": "sem_preload.html#loading-blavaan-objects",
    "title": "10  Integrated SEM Workflow",
    "section": "3. Loading blavaan Objects",
    "text": "3. Loading blavaan Objects\nggsem seamlessly integrates with blavaan objects for Bayesian structural equation modeling, providing access to posterior distributions and Bayesian fit statistics.\n\nStep 1: Fit Your Bayesian SEM\n\n# Fit the Bayesian SEM model\nfit_bayes &lt;- bsem(model, data = HolzingerSwineford1939)\n\n\nSAMPLING FOR MODEL 'stanmarg' NOW (CHAIN 1).\nChain 1: \nChain 1: Gradient evaluation took 0.000711 seconds\nChain 1: 1000 transitions using 10 leapfrog steps per transition would take 7.11 seconds.\nChain 1: Adjust your expectations accordingly!\nChain 1: \nChain 1: \nChain 1: Iteration:    1 / 1500 [  0%]  (Warmup)\nChain 1: Iteration:  150 / 1500 [ 10%]  (Warmup)\nChain 1: Iteration:  300 / 1500 [ 20%]  (Warmup)\nChain 1: Iteration:  450 / 1500 [ 30%]  (Warmup)\nChain 1: Iteration:  501 / 1500 [ 33%]  (Sampling)\nChain 1: Iteration:  650 / 1500 [ 43%]  (Sampling)\nChain 1: Iteration:  800 / 1500 [ 53%]  (Sampling)\nChain 1: Iteration:  950 / 1500 [ 63%]  (Sampling)\nChain 1: Iteration: 1100 / 1500 [ 73%]  (Sampling)\nChain 1: Iteration: 1250 / 1500 [ 83%]  (Sampling)\nChain 1: Iteration: 1400 / 1500 [ 93%]  (Sampling)\nChain 1: Iteration: 1500 / 1500 [100%]  (Sampling)\nChain 1: \nChain 1:  Elapsed Time: 3.082 seconds (Warm-up)\nChain 1:                5.54 seconds (Sampling)\nChain 1:                8.622 seconds (Total)\nChain 1: \n\nSAMPLING FOR MODEL 'stanmarg' NOW (CHAIN 2).\nChain 2: \nChain 2: Gradient evaluation took 0.000247 seconds\nChain 2: 1000 transitions using 10 leapfrog steps per transition would take 2.47 seconds.\nChain 2: Adjust your expectations accordingly!\nChain 2: \nChain 2: \nChain 2: Iteration:    1 / 1500 [  0%]  (Warmup)\nChain 2: Iteration:  150 / 1500 [ 10%]  (Warmup)\nChain 2: Iteration:  300 / 1500 [ 20%]  (Warmup)\nChain 2: Iteration:  450 / 1500 [ 30%]  (Warmup)\nChain 2: Iteration:  501 / 1500 [ 33%]  (Sampling)\nChain 2: Iteration:  650 / 1500 [ 43%]  (Sampling)\nChain 2: Iteration:  800 / 1500 [ 53%]  (Sampling)\nChain 2: Iteration:  950 / 1500 [ 63%]  (Sampling)\nChain 2: Iteration: 1100 / 1500 [ 73%]  (Sampling)\nChain 2: Iteration: 1250 / 1500 [ 83%]  (Sampling)\nChain 2: Iteration: 1400 / 1500 [ 93%]  (Sampling)\nChain 2: Iteration: 1500 / 1500 [100%]  (Sampling)\nChain 2: \nChain 2:  Elapsed Time: 2.875 seconds (Warm-up)\nChain 2:                5.855 seconds (Sampling)\nChain 2:                8.73 seconds (Total)\nChain 2: \n\nSAMPLING FOR MODEL 'stanmarg' NOW (CHAIN 3).\nChain 3: \nChain 3: Gradient evaluation took 0.000348 seconds\nChain 3: 1000 transitions using 10 leapfrog steps per transition would take 3.48 seconds.\nChain 3: Adjust your expectations accordingly!\nChain 3: \nChain 3: \nChain 3: Iteration:    1 / 1500 [  0%]  (Warmup)\nChain 3: Iteration:  150 / 1500 [ 10%]  (Warmup)\nChain 3: Iteration:  300 / 1500 [ 20%]  (Warmup)\nChain 3: Iteration:  450 / 1500 [ 30%]  (Warmup)\nChain 3: Iteration:  501 / 1500 [ 33%]  (Sampling)\nChain 3: Iteration:  650 / 1500 [ 43%]  (Sampling)\nChain 3: Iteration:  800 / 1500 [ 53%]  (Sampling)\nChain 3: Iteration:  950 / 1500 [ 63%]  (Sampling)\nChain 3: Iteration: 1100 / 1500 [ 73%]  (Sampling)\nChain 3: Iteration: 1250 / 1500 [ 83%]  (Sampling)\nChain 3: Iteration: 1400 / 1500 [ 93%]  (Sampling)\nChain 3: Iteration: 1500 / 1500 [100%]  (Sampling)\nChain 3: \nChain 3:  Elapsed Time: 3.136 seconds (Warm-up)\nChain 3:                6.103 seconds (Sampling)\nChain 3:                9.239 seconds (Total)\nChain 3: \nComputing post-estimation metrics (including lvs if requested)...\n\nclass(fit_bayes)\n\n[1] \"blavaan\"\nattr(,\"package\")\n[1] \"blavaan\"\n\n\n\n\nStep 2: Optional semPaths Visualization\n\n# Create semPaths object with Bayesian parameter estimates\nsem_paths &lt;- semPaths(fit_bayes, \n                      what = \"paths\", \n                      residuals = TRUE,\n                      whatLabels = \"par\")\n\n\n\n\n\n\n\n\n\n\nStep 3: Launch ggsem with blavaan Objects\nWhen only blavaan class object is provided (the statistical model), then specify it as object in ggsem(). If you specify visualization output as object, then provide the model input as model argument. The qgraph output can also be pre-loaded as object without any model object.\n\n# Option A: Direct blavaan object loading\nggsem(object = fit_bayes)\n\n# Option B: semPaths object with blavaan model\nggsem(object = sem_paths, model = fit_bayes)\n\n# Option C: semPaths object only (limited functionality)\nggsem(object = sem_paths)\n\n\n\n\n\n\nFigure 4. A SEM generated from pre-load blavaan object and pre-loaded semPlot object.\n\n\n\n\nNote: Option C provides only visual customization without access to Bayesian statistical features since no model object is available.\nWhat Happens When You Load a blavaan Object:\n\nBayesian SEM diagram with posterior means as parameter estimates\nAccess to posterior distributions and credible intervals\nBayesian fit statistics (PPP, DIC, WAIC, LOOIC)\nMCMC diagnostics and convergence information\nFull visual customization capabilities\n\nBayesian-Specific Features:\n\nParameter Estimates: Posterior means with credible intervals\nFit Statistics: PPP, DIC, WAIC, LOOIC instead of frequentist indices\nDiagnostics: MCMC convergence information\n\nKey Differences from lavaan Objects:\n\nPosterior means instead of maximum likelihood estimates\nCredible intervals instead of confidence intervals\nBayesian p-values (PPP) instead of frequentist p-values\nInformation criteria (DIC/WAIC) instead of traditional fit indices\n\nAll three object types (lavaan, semPlot/qgraph, and blavaan) can be loaded directly into ggsem using the same simple workflow: ggsem(object = your_model), with optional additional parameters for customization and, in the case of semPlot objects, the original model for full statistical functionality.",
    "crumbs": [
      "Single-Group Workflow Using Pre-loaded Objects",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Integrated SEM Workflow</span>"
    ]
  },
  {
    "objectID": "sem_preload.html#loading-lavaanplotobjects",
    "href": "sem_preload.html#loading-lavaanplotobjects",
    "title": "10  Integrated SEM Workflow",
    "section": "4. Loading lavaanPlotObjects",
    "text": "4. Loading lavaanPlotObjects\nlavaanPlot generates SEM diagrams from lavaan models using DiagrammeR, providing customizable node and edge styling. The package creates grViz objects that can be imported into ggsem for interactive parameter visualization.\nUnlike the above three, when pre-loading lavaanPlot, you need both object and model.\n\nStep 1: Create lavaanPlot Visualization\n\nlibrary(lavaanPlot)\n\nlavaanplot_obj &lt;- lavaanPlot(\n  model = fit, \n  node_options = list(shape = \"box\", alpha = 0.5),\n  edge_options = list(color = \"gray\"), \n  coefs = TRUE\n)\n\nclass(lavaanplot_obj)  # \"grViz\" \"htmlwidget\"\n\n[1] \"grViz\"      \"htmlwidget\"\n\nlavaanplot_obj\n\n\n\n\n\n\n\nStep 2: Launch ggsem with lavaanPlot Object\nThe plot generated with lavaanPlot is grViz class, and it should be loaded as object, while its statistical model that has been used to create the grViz object is specified as model in ggsem().\n\n# Load with both lavaanPlot visualization and lavaan model\nggsem(object = lavaanplot_obj, model = fit, width = 35, height = 35)\n\n\n\n\n\n\nFigure 5. A SEM generated from pre-loaded lavaanPlot object.\n\n\n\n\nSo far, only rectangles and ovals are faithfully transferred from lavaanPlot to ggsem.\n\n\nImportant Requirements\nRequired Parameters: Both object (lavaanPlot visualization) and model (original lavaan model) must be provided.\nLayout Preservation: lavaanPlot layouts are fixed in ggsem. The “Custom” layout option will be selected, but layout algorithms cannot be applied.\nRendering Differences: Visual elements may differ slightly due to the transition from DiagrammeR to ggplot2 rendering engines.\n\n\nWhat ggsem Preserves:\n\nColor schemes and styling\nNode shapes and structural layout\nEdge connections and path directions\nLabel positioning\nDiagram topology\n\n\n\nWhat May Differ:\n\nCurved line curvature\nNode sizes and proportions\nFont rendering and spacing\nArrowhead styling",
    "crumbs": [
      "Single-Group Workflow Using Pre-loaded Objects",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Integrated SEM Workflow</span>"
    ]
  },
  {
    "objectID": "sem_preload.html#loading-tidysem-objects",
    "href": "sem_preload.html#loading-tidysem-objects",
    "title": "10  Integrated SEM Workflow",
    "section": "5. Loading tidySEM Objects",
    "text": "5. Loading tidySEM Objects\nThe ggsem package integrates with tidySEM objects, allowing you to import and customize visualizations created using tidySEM’s workflow. The prepare_graph() function produces sem_graph objects that are fully compatible with ggsem.\nWhen pre-loading tidySEM object, you need both object and model inputs specified. sem_graph class object from tidySEM has to be specified as object in ggsem(), while model specifies a model object that has been used to draw tidySEM plot object.\n\nStep 1: Create tidySEM Object\n\nlibrary(tidySEM)\n\nWarning: package 'tidySEM' was built under R version 4.4.3\n\n\nRegistered S3 method overwritten by 'tidySEM':\n  method          from  \n  predict.MxModel OpenMx\n\nlibrary(lavaan)\n\nHS.model &lt;- '\n  visual  =~ x1 + x2 + x3\n  textual =~ x4 + x5 + x6\n  speed   =~ x7 + x8 + x9\n'\n\nfit &lt;- sem(HS.model, data = HolzingerSwineford1939)\n\n# Create custom layout\nlay &lt;- get_layout(\"visual\", \"\", \"\", \"\", \"textual\", \"\", \"speed\", \"\", \"\",\n                  \"x1\", \"x2\", \"x3\", \"x4\", \"x5\", \"x6\", \"x7\", \"x8\", \"x9\", \n                  rows = 2)\n\n# Prepare graph object\ntidysem_object &lt;- prepare_graph(model = fit, layout = lay)\nplot(tidysem_object)\n\n\n\n\n\n\n\nclass(tidysem_object)  # \"sem_graph\"\n\n[1] \"sem_graph\"\n\n\n\n\nStep 2: Launch ggsem with sem_graph Object\n\n# Load the tidySEM object in ggsem\nggsem(object = tidysem_object, model = fit)\n\n\n\n\n\n\nFigure 6. A SEM generated from pre-loaded tidySEM object and lavaan model object.\n\n\n\n\n\n\nImportant Notes\nLayout Preservation: tidySEM layouts are fixed in ggsem. The “Custom” layout option will be selected, but layout algorithms cannot be applied.\nEdge Label Preservation: tidySEM objects preserve edge labels exactly as specified, including significance notation.\n\n\nWhat ggsem Preserves:\n\nComplete visual structure with custom layouts\nNode relationships and path diagram structure\nStatistical model information\nParameter estimates and specifications\nEdge labels including significance stars\n\n\n\nWhat ggsem Cannot Modify:\n\nLayout algorithm (preserved as “Custom”)\nBase node positions\nOverall structural arrangement\nEdge label significance notation\n\nNote: Always provide both the sem_graph object and the original lavaan (or blavaan) model.",
    "crumbs": [
      "Single-Group Workflow Using Pre-loaded Objects",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Integrated SEM Workflow</span>"
    ]
  },
  {
    "objectID": "sem_preload.html#loading-openmx-objects",
    "href": "sem_preload.html#loading-openmx-objects",
    "title": "10  Integrated SEM Workflow",
    "section": "6. Loading OpenMx Objects",
    "text": "6. Loading OpenMx Objects\nThe ggsem package provides integration with OpenMx models, optionally through tidySEM’s visualization workflow. You can just pre-load OpenMx model as object without plot object, or you can pre-load OpenMx model as model and tidySEM plot as object.\n\nlibrary(OpenMx)\n\nWarning: package 'OpenMx' was built under R version 4.4.3\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n# Use built-in data\ndata(HolzingerSwineford1939, package = \"lavaan\")\n\n# Simple preparation - use all data, no grouping\nhs_data &lt;- HolzingerSwineford1939 %&gt;%\n  dplyr::select(-c(id, sex, ageyr, agemo, grade, school)) %&gt;%  # Remove school and other vars\n  na.omit()\n\n# Single-group CFA model\ncfa_model &lt;- mxModel(\n  \"HolzingerSwineford_CFA\",\n  type = \"RAM\",\n  mxData(hs_data, type = \"raw\"),\n  manifestVars = paste0(\"x\", 1:9),\n  latentVars = c(\"visual\", \"textual\", \"speed\"),\n\n  # Factor loadings with labels\n  mxPath(from = \"visual\", to = c(\"x1\", \"x2\", \"x3\"),\n         free = c(FALSE, TRUE, TRUE),  # First loading fixed for identification\n         values = c(1, 0.8, 0.8),\n         labels = c(\"visual_x1\", \"visual_x2\", \"visual_x3\")),\n\n  mxPath(from = \"textual\", to = c(\"x4\", \"x5\", \"x6\"),\n         free = c(FALSE, TRUE, TRUE),\n         values = c(1, 0.8, 0.8),\n         labels = c(\"textual_x4\", \"textual_x5\", \"textual_x6\")),\n\n  mxPath(from = \"speed\", to = c(\"x7\", \"x8\", \"x9\"),\n         free = c(FALSE, TRUE, TRUE),\n         values = c(1, 0.8, 0.8),\n         labels = c(\"speed_x7\", \"speed_x8\", \"speed_x9\")),\n\n  # Residual variances\n  mxPath(from = paste0(\"x\", 1:9), arrows = 2, free = TRUE,\n         values = rep(0.5, 9),\n         labels = paste0(\"resid_x\", 1:9)),\n\n  # Factor variances\n  mxPath(from = c(\"visual\", \"textual\", \"speed\"), arrows = 2, free = TRUE,\n         values = c(1, 1, 1),\n         labels = c(\"var_visual\", \"var_textual\", \"var_speed\")),\n\n  # Factor covariances\n  mxPath(from = \"visual\", to = \"textual\", arrows = 2, free = TRUE,\n         values = 0.3, labels = \"cov_visual_textual\"),\n  mxPath(from = \"visual\", to = \"speed\", arrows = 2, free = TRUE,\n         values = 0.2, labels = \"cov_visual_speed\"),\n  mxPath(from = \"textual\", to = \"speed\", arrows = 2, free = TRUE,\n         values = 0.2, labels = \"cov_textual_speed\"),\n\n  # Means/intercepts\n  mxPath(from = \"one\", to = paste0(\"x\", 1:9), free = TRUE,\n         values = colMeans(hs_data, na.rm = TRUE),\n         labels = paste0(\"mean_x\", 1:9))\n)\n\n# Fit the model\ncfa_fit &lt;- mxRun(cfa_model)\n\nRunning HolzingerSwineford_CFA with 30 parameters\n\nsummary(cfa_fit)\n\nSummary of HolzingerSwineford_CFA \n \nfree parameters:\n                 name matrix     row     col  Estimate  Std.Error A\n1           visual_x2      A      x2  visual 0.5535011 0.10921118  \n2           visual_x3      A      x3  visual 0.7293714 0.11723235  \n3          textual_x5      A      x5 textual 1.1130765 0.06498136  \n4          textual_x6      A      x6 textual 0.9261458 0.05619111  \n5            speed_x8      A      x8   speed 1.1799503 0.15025376  \n6            speed_x9      A      x9   speed 1.0815303 0.19508113  \n7            resid_x1      S      x1      x1 0.5490550 0.11901095  \n8            resid_x2      S      x2      x2 1.1338396 0.10425397  \n9            resid_x3      S      x3      x3 0.8443230 0.09506139  \n10           resid_x4      S      x4      x4 0.3711727 0.04796107  \n11           resid_x5      S      x5      x5 0.4462549 0.05793001  \n12           resid_x6      S      x6      x6 0.3562030 0.04343945  \n13           resid_x7      S      x7      x7 0.7993917 0.08755798  \n14           resid_x8      S      x8      x8 0.4876975 0.09164537  \n15           resid_x9      S      x9      x9 0.5661306 0.09056512  \n16         var_visual      S  visual  visual 0.8093136 0.14969561  \n17 cov_visual_textual      S  visual textual 0.4082316 0.07966415  \n18        var_textual      S textual textual 0.9794930 0.11219920  \n19   cov_visual_speed      S  visual   speed 0.2622248 0.05537891  \n20  cov_textual_speed      S textual   speed 0.1734948 0.04931108  \n21          var_speed      S   speed   speed 0.3837472 0.09204134  \n22            mean_x1      M       1      x1 4.9357697 0.06717776  \n23            mean_x2      M       1      x2 6.0880399 0.06775428  \n24            mean_x3      M       1      x3 2.2504153 0.06508019  \n25            mean_x4      M       1      x4 3.0609081 0.06698704  \n26            mean_x5      M       1      x5 4.3405316 0.07425801  \n27            mean_x6      M       1      x6 2.1855719 0.06304459  \n28            mean_x7      M       1      x7 4.1859021 0.06269525  \n29            mean_x8      M       1      x8 5.5270764 0.05826912  \n30            mean_x9      M       1      x9 5.3741233 0.05806980  \n\nModel Statistics: \n               |  Parameters  |  Degrees of Freedom  |  Fit (-2lnL units)\n       Model:             30                   2679               7475.49\n   Saturated:             54                   2655                    NA\nIndependence:             18                   2691                    NA\nNumber of observations/statistics: 301/2709\n\nInformation Criteria: \n      |  df Penalty  |  Parameters Penalty  |  Sample-Size Adjusted\nAIC:       2117.490               7535.490                 7542.379\nBIC:      -7813.859               7646.703                 7551.560\nTo get additional fit indices, see help(mxRefModels)\ntimestamp: 2025-12-18 17:11:31 \nWall clock time: 0.159466 secs \noptimizer:  SLSQP \nOpenMx version number: 2.21.13 \nNeed help?  See help(mxSummary) \n\n\n\nApproach 1: OpenMx Model Only\nLoad OpenMx models directly for automatic visualization generation within ggsem using object argument.\n\nggsem(object = cfa_fit)\n\n\n\n\n\n\nFigure 7. A SEM generated from pre-loaded OpenMx object.\n\n\n\n\nUse case: Quick visualization without predefined layouts. ggsem automatically generates the SEM diagram from the OpenMx model structure.\n\n\nApproach 2: OpenMx Model + tidySEM Visualization\nCombine OpenMx estimation with tidySEM’s layout control for customized visual presentations. In this case, object should be specified for tidySEM object, and model should be specified to OpenMx object.\n\nlibrary(tidySEM)\n# Prepare visualization with tidySEM\nmx_graph &lt;- prepare_graph(cfa_fit)\nplot(mx_graph)\n\n\n\n\n\n\n\n\n\n# Import with custom layout\nggsem(object = mx_graph, model = cfa_fit)\n\n\n\n\n\n\nFigure 8. A SEM generated from pre-loaded tidySEM object and OpenMx object.\n\n\n\n\nUse case: Predefined layouts (see above) and customized visual styling. tidySEM can also provide layout control while OpenMx handles statistical estimation.\n\n\nKey Differences:\nApproach 1 (OpenMx only):\n\nggsem generates automatic layout\nQuick setup, minimal code\nLess visual customization control\n\nApproach 2 (OpenMx + tidySEM):\n\nCustom layouts via tidySEM\nEnhanced visual styling options\nPreserves specific node positioning\nRequires additional preparation step",
    "crumbs": [
      "Single-Group Workflow Using Pre-loaded Objects",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Integrated SEM Workflow</span>"
    ]
  },
  {
    "objectID": "sem_preload.html#loading-openmx-objects-created-with-umx-package",
    "href": "sem_preload.html#loading-openmx-objects-created-with-umx-package",
    "title": "10  Integrated SEM Workflow",
    "section": "7. Loading OpenMx Objects Created with umx Package",
    "text": "7. Loading OpenMx Objects Created with umx Package\nYou can also visualize OpenMx objects created with umx package, which provides utility functions to handle OpenMx model objects, as shown below. This example is from the umx documentation website (https://tbates.github.io/):\n\nlibrary(umx)\nlibrary(OpenMx)\nlibrary(ggsem)\nm1 = umxRAM(\"cars\", data = mtcars, type=\"cov\",\n            umxPath(c(\"wt\", \"disp\"), to = \"mpg\"),\n            umxPath(\"wt\", with = \"disp\"),\n            umxPath(var = c(\"wt\", \"disp\", \"mpg\"))\n)\n\n\n\nTable: Parameter loadings for model 'cars'\n\n|   |name           |  Estimate|       SE|type          |\n|:--|:--------------|---------:|--------:|:-------------|\n|5  |disp_with_wt   |   104.319|   27.773|Manifest Cov  |\n|1  |disp_to_mpg    |    -0.018|    0.009|Manifest path |\n|2  |wt_to_mpg      |    -3.351|    1.108|Manifest path |\n|3  |mpg_with_mpg   |     7.709|    1.927|Residual      |\n|4  |disp_with_disp | 14880.775| 3720.082|Residual      |\n|6  |wt_with_wt     |     0.927|    0.232|Residual      |\n\nplot(m1) # plotted with umx package\n\n\n\n\n\nggsem plots the final estimated values from OpenMx objects, while umx plots starting values, so the plotting outputs may look different.\n\nggsem(m1)\n\n\n\n\n\n\nFigure 9. A path diagram generated from pre-loaded OpenMx object using the umx package.\n\n\n\n\nThis is an example with customized colors of nodes, edges and loop arrows.",
    "crumbs": [
      "Single-Group Workflow Using Pre-loaded Objects",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Integrated SEM Workflow</span>"
    ]
  },
  {
    "objectID": "sem_preload.html#loading-mplus-object",
    "href": "sem_preload.html#loading-mplus-object",
    "title": "10  Integrated SEM Workflow",
    "section": "8. Loading Mplus Object",
    "text": "8. Loading Mplus Object\nThe code chunk below is directly from the documentation website of MplusAutomation (https://michaelhallquist.github.io/MplusAutomation/). You can only pre-laod Mplus model object by specifying the object parameter in ggsem().\nLoad Mplus models directly into ggsem using object argument:\n\nlibrary(MplusAutomation) \nlibrary(ggsem)\n\npathmodel &lt;- mplusObject(\n   TITLE = \"MplusAutomation Example - Path Model;\",\n   MODEL = \"\n     mpg ON hp;\n     wt ON disp;\",\n   OUTPUT = \"CINTERVAL;\",\n   rdata = mtcars)\n\nfit &lt;- mplusModeler(pathmodel, modelout = \"model1.inp\", run = 1L)\nclass(fit)\n\n[1] \"mplusObject\" \"list\"       \n\n\n\n# Import directly into ggsem\nggsem(object = fit)\n\n\n\n\n\n\nFigure 10. A path diagram generated from pre-loaded Mplus object.\n\n\n\n\nNotice that the parameter estimate values from the figure match to those from the Mplus model:\n\nlibrary(texreg)\nscreenreg(fit, summaries = c(\"Observations\", \"CFI\", \"SRMR\"), single.row=TRUE)\n\n\n==================================\n                  TITLE           \n----------------------------------\n MPG&lt;-HP          -0.06 (0.01) ***\n WT&lt;-DISP          0.01 (0.00) ***\n WT&lt;-&gt;MPG         -1.02 (0.38) ** \n MPG&lt;-Intercepts  29.59 (1.53) ***\n WT&lt;-Intercepts    1.82 (0.18) ***\n MPG&lt;-&gt;MPG        14.04 (3.52) ***\n WT&lt;-&gt;WT           0.21 (0.06) ***\n----------------------------------\nObservations      32              \nCFI                0.87           \nSRMR               0.17           \n==================================\n*** p &lt; 0.001; ** p &lt; 0.01; * p &lt; 0.05",
    "crumbs": [
      "Single-Group Workflow Using Pre-loaded Objects",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Integrated SEM Workflow</span>"
    ]
  },
  {
    "objectID": "sem_preload.html#loading-semplot-objects-with-modifications-from-semptools-package",
    "href": "sem_preload.html#loading-semplot-objects-with-modifications-from-semptools-package",
    "title": "10  Integrated SEM Workflow",
    "section": "9. Loading semPlot Objects with Modifications from semptools Package",
    "text": "9. Loading semPlot Objects with Modifications from semptools Package\nThe semptools package can be used to create a customized layout for semPlot objects or modify other properties of the plot objects. These modifications from semptools can also be pre-loaded into ggsem(). Here, I directly use examples from the documentation of semptools (https://sfcheung.github.io/semptools/).\n\nAnnotations\nAdd statistical annotations like significance markers to semPlot objects:\n\nlibrary(lavaan)\nlibrary(semptools)\n\nWarning: package 'semptools' was built under R version 4.4.3\n\nlibrary(semPlot)\n\nmod_pa &lt;-\n  'x1 ~~ x2\n  x3 ~  x1 + x2\n  x4 ~  x1 + x3\n '\nfit_pa &lt;- lavaan::sem(mod_pa, pa_example)\nparameterEstimates(fit_pa)\n\n  lhs op rhs   est    se     z pvalue ci.lower ci.upper\n1  x1 ~~  x2 0.005 0.097 0.054  0.957   -0.186    0.196\n2  x3  ~  x1 0.537 0.097 5.551  0.000    0.348    0.727\n3  x3  ~  x2 0.376 0.093 4.050  0.000    0.194    0.557\n4  x4  ~  x1 0.111 0.127 0.875  0.382   -0.138    0.361\n5  x4  ~  x3 0.629 0.108 5.801  0.000    0.416    0.841\n6  x3 ~~  x3 0.874 0.124 7.071  0.000    0.632    1.117\n7  x4 ~~  x4 1.194 0.169 7.071  0.000    0.863    1.525\n8  x1 ~~  x1 0.933 0.132 7.071  0.000    0.674    1.192\n9  x2 ~~  x2 1.017 0.144 7.071  0.000    0.735    1.298\n\nm &lt;- matrix(c(\"x1\",   NA,  NA,   NA,\n              NA, \"x3\",  NA, \"x4\",\n              \"x2\",   NA,  NA,   NA), byrow = TRUE, 3, 4)\np_pa &lt;- semPaths(fit_pa, whatLabels = \"est\",\n                 sizeMan = 10,\n                 edge.label.cex = 1.15,\n                 style = \"ram\",\n                 nCharNodes = 0, nCharEdges = 0,\n                 layout = m)\n\n\n\n\n\n\n\n\n\nggsem(object = p_pa)\n\n\n\n\n\n\nFigure 11. A path diagram generated from pre-loaded semPlot object.\n\n\n\n\n\np_pa2 &lt;- mark_sig(p_pa, fit_pa)\nplot(p_pa2)\n\n\n\n\n\n\n\n\n\nggsem(object = p_pa2)\n\n\n\n\n\n\nFigure 12. A path diagram generated from pre-loaded semPlot object with modified annotations using semptools package.\n\n\n\n\n\n\nCustomized Layout\nCreate advanced custom layouts using semptools layout functions:\n\nmod &lt;-\n  'f1 =~ x01 + x02 + x03\n   f2 =~ x04 + x05 + x06 + x07\n   f3 =~ x08 + x09 + x10\n   f4 =~ x11 + x12 + x13 + x14\n   f3 ~  f1 + f2\n   f4 ~  f1 + f3\n  '\n\n\nfit &lt;- lavaan::sem(mod, cfa_example)\n\n\np1 &lt;- semPaths(fit, whatLabels=\"est\",\n              sizeMan = 5,\n              node.width = 1,\n              edge.label.cex = .75,\n              style = \"ram\",\n              mar = c(5, 5, 5, 5)) # original layout\n\n\n\n\n\n\n\n\n\nggsem(p1, width = 35, height = 35)\n\n\n\n\n\n\nFigure 13. A SEM diagram generated from pre-loaded semPlot object.\n\n\n\n\nNow, we modify the layout using functions from the semptools package.\n\nindicator_order  &lt;- c(\"x04\", \"x05\", \"x06\", \"x07\",\n                      \"x01\", \"x02\", \"x03\",\n                      \"x11\", \"x12\", \"x13\", \"x14\",\n                      \"x08\", \"x09\", \"x10\")\n\nindicator_factor &lt;- c( \"f2\",  \"f2\",  \"f2\",  \"f2\",\n                       \"f1\",  \"f1\",  \"f1\",\n                       \"f4\",  \"f4\",  \"f4\",  \"f4\",\n                       \"f3\",  \"f3\",  \"f3\")\n\n\nfactor_layout &lt;- layout_matrix(f1 = c(1, 1),\n                               f2 = c(3, 1),\n                               f3 = c(2, 2),\n                               f4 = c(2, 3))\n\n\nfactor_point_to &lt;- layout_matrix(left = c(1, 1),\n                                 left = c(3, 1),\n                                 down = c(2, 2),\n                                 down = c(2, 3))\n\np2 &lt;- set_sem_layout(p1,\n                     indicator_order = indicator_order,\n                     indicator_factor = indicator_factor,\n                     factor_layout = factor_layout,\n                     factor_point_to = factor_point_to)\nplot(p2) # modified layout\n\n\n\n\n\n\n\n\n\nggsem(p2, width = 35, height = 35)\n\n\n\n\n\n\nFigure 14. A SEM diagram generated from pre-loaded semPlot object with modified layout using semptools package.\n\n\n\n\nMost (if not all) semptools enhancements (layouts, annotations, styling) are preserved when loaded into ggsem, providing a transition from static customized plots to interactive exploration.",
    "crumbs": [
      "Single-Group Workflow Using Pre-loaded Objects",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Integrated SEM Workflow</span>"
    ]
  },
  {
    "objectID": "network_preload.html",
    "href": "network_preload.html",
    "title": "11  Integrated Network Workflow",
    "section": "",
    "text": "Purpose of this workflow:\nIf you want to modify aesthetics using interactive parameter visualization (dynamic dropdown of all nodes and edges etc), then you should pre-load output objects from other packages into ggsem.",
    "crumbs": [
      "Single-Group Workflow Using Pre-loaded Objects",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Integrated Network Workflow</span>"
    ]
  },
  {
    "objectID": "network_preload.html#loading-igraph-objects",
    "href": "network_preload.html#loading-igraph-objects",
    "title": "11  Integrated Network Workflow",
    "section": "1. Loading igraph objects",
    "text": "1. Loading igraph objects\nThe ggsem package provides support for igraph objects for plotting networks.\n\nDirect igraph Object Import\nLoad igraph networks directly into ggsem for interactive visualization and customization:\n\nlibrary(igraph)\nlibrary(ggsem)\n\nset.seed(2026)\n# Create a sample ring graph\ng &lt;- make_ring(10)\n\n# Verify object class\nclass(g)  # Returns \"igraph\"\n\n[1] \"igraph\"\n\n\n\n# Import directly into ggsem\nggsem(object = g, width = 35, height = 35)\n\n\n\n\n\n\nFigure 1. A network diagram generated from pre-loaded igraph object\n\n\n\n\n\n\nPractical Examples with Realistic Networks\n\nSocial Network Analysis\n\nset.seed(2026)\n# Create a social network with attributes\nsocial_g &lt;- make_graph(~ Alice-Bob, Bob-Charlie, Charlie-David, \n                       David-Eve, Eve-Alice, Alice-Charlie,\n                       Bob-David)\n\n# Add vertex attributes\nV(social_g)$name &lt;- c(\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\")\nV(social_g)$group &lt;- c(\"A\", \"A\", \"B\", \"B\", \"A\")\nV(social_g)$centrality &lt;- degree(social_g)\n\n# Add edge attributes  \nE(social_g)$weight &lt;- c(1, 2, 1, 3, 2, 1, 1)\nE(social_g)$type &lt;- c(\"friend\", \"colleague\", \"friend\", \"family\", \n                      \"friend\", \"colleague\", \"friend\")\n\nplot(social_g)\n\n\n\n\n\n\n\n\n\n# Import to ggsem with attributes preserved\nggsem(object = social_g)\n\n\n\n\n\n\nFigure 2. A network diagram generated from pre-loaded igraph object\n\n\n\n\n\n\nWeighted Network with Community Structure\n\n# Create a weighted network with clear community structure\nset.seed(123)\nweighted_g &lt;- sample_sbm(\n  n = 12,\n  pref.matrix = matrix(c(0.8, 0.1, 0.1, 0.8), nrow = 2),\n  block.sizes = c(6, 6),\n  directed = FALSE\n)\n\n# Add edge weights\nE(weighted_g)$weight &lt;- round(runif(ecount(weighted_g), 0.1, 1), 2) # limit decimal places, otherwise they clutter the overall visuals\n\nplot(weighted_g)\n\n\n\n\n\n\n\n\n\n# Import for interactive refinement\nggsem(object = weighted_g, width = 45, height = 45)\n\n\n\n\n\n\nFigure 3. A network diagram generated from pre-loaded igraph object. Gradient colors have been applied to nodes in the app.\n\n\n\n\n\n\n\nBipartite Network Support\n\nCreating Bipartite igraph Objects\n\n# Method 1: From bipartite adjacency matrix\nmat &lt;- matrix(c(1,0,1,1,0,1,0,1,0,1), nrow = 2, byrow = TRUE)\nbipartite_g &lt;- graph_from_incidence_matrix(mat)\n\n# Method 2: Explicit type attribute specification\nbipartite_g &lt;- make_full_bipartite_graph(3, 2)  # 3 nodes of type1, 2 nodes of type2\nV(bipartite_g)$type &lt;- rep(c(TRUE, FALSE), times = c(3, 2))  # TRUE for first partition, FALSE for second\n\nplot(bipartite_g)\n\n\n\n\n\n\n\n\n\n# Import to ggsem with bipartite structure \nggsem(object = bipartite_g)\n\n\n\n\n\n\nFigure 4. A bipartite network diagram generated from pre-loaded igraph object. Color of the nodes in the top row has been modified.",
    "crumbs": [
      "Single-Group Workflow Using Pre-loaded Objects",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Integrated Network Workflow</span>"
    ]
  },
  {
    "objectID": "network_preload.html#preserved-igraph-features",
    "href": "network_preload.html#preserved-igraph-features",
    "title": "11  Integrated Network Workflow",
    "section": "Preserved igraph Features",
    "text": "Preserved igraph Features\n\nNetwork Properties Maintained:\n\nVertex attributes: names, groups, centrality measures\nEdge attributes: weights, types, directions\nGraph structure: community detection, clustering coefficients\nLayout information: when specified in igraph\nBipartite structure: type attributes and two-mode organization\n\n\n\nBipartite-Specific Preservation:\n\nVertex types and partition membership automatically detected\nBipartite layout maintained with clear separation between partitions\nType-based coloring options for different entity classes in the app",
    "crumbs": [
      "Single-Group Workflow Using Pre-loaded Objects",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Integrated Network Workflow</span>"
    ]
  },
  {
    "objectID": "network_preload.html#layout-integration",
    "href": "network_preload.html#layout-integration",
    "title": "11  Integrated Network Workflow",
    "section": "11.1 Layout Integration",
    "text": "11.1 Layout Integration\n\nPreserving igraph Layouts:\n\n# Use igraph's layout algorithms\nset.seed(2026)\ng &lt;- make_star(10)\n\n# Calculate layout in igraph\nlayout_ig &lt;- layout_with_fr(g)\n\nplot(g)\n\n\n\n\n\n\n\n\n\n# Import to ggsem with layout preserved\nggsem(object = g, width = 35, height = 35)  # Layout automatically transferred\n\nWhile the individual node’s location may differ due to differences in random seeds between inside and outside the ggsem app, the overall layout is preserved.\n\n\n\n\n\nFigure 5. A network diagram generated from pre-loaded igraph object with pre-specified layout.",
    "crumbs": [
      "Single-Group Workflow Using Pre-loaded Objects",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Integrated Network Workflow</span>"
    ]
  },
  {
    "objectID": "network_preload.html#weight-and-attribute-visualization",
    "href": "network_preload.html#weight-and-attribute-visualization",
    "title": "11  Integrated Network Workflow",
    "section": "11.2 Weight and Attribute Visualization",
    "text": "11.2 Weight and Attribute Visualization\n\nAutomatic Weight Mapping:\n\n# Edge weights automatically inform visualization\nweighted_net &lt;- make_full_graph(5)\nE(weighted_net)$weight &lt;- c(1, 2, 3, 4, 5, 3, 2, 4, 1, 5)\n\nplot(weighted_net)\n\n\n\n\n\n\n\n\n\n# In ggsem: weights can control edge width, color, or transparency\nggsem(object = weighted_net, width = 35, height = 35)\n\n\n\n\n\n\nFigure 6. A network diagram generated from pre-loaded igraph object with pre-specified weights.\n\n\n\n\nWeights information is inherited by ggsem.\n\n\nCommunity-Aware Styling:\n\n# Complete network analysis workflow\nset.seed(123)\ng &lt;- sample_pa(20, power = 1.2, m = 2)  # Preferential attachment\n\n# Analytical steps in igraph\nV(g)$degree &lt;- degree(g)\nV(g)$betweenness &lt;- betweenness(g)\ncommunities &lt;- cluster_walktrap(g)\nV(g)$community &lt;- communities$membership\nplot(g)\n\n\n\n\n\n\n\n\n\n# Interactive refinement in ggsem\nggsem(object = g, width = 45, height = 45)\n\n\n\n\n\n\nFigure 7. A network diagram generated from pre-loaded igraph object with pre-specified community information, which is used to perform clustering on the nodes based on their community properties in the app.\n\n\n\n\nYou can perform clustering by assigning unique color to each cluster of the nodes because g contains information about community.",
    "crumbs": [
      "Single-Group Workflow Using Pre-loaded Objects",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Integrated Network Workflow</span>"
    ]
  },
  {
    "objectID": "network_preload.html#loading-qgraph-network-objects",
    "href": "network_preload.html#loading-qgraph-network-objects",
    "title": "11  Integrated Network Workflow",
    "section": "2. Loading qgraph network objects",
    "text": "2. Loading qgraph network objects\nAdditionally, the ggsem package provides support for qgraph objects for plotting networks.\n\nDirect qgraph Network Import\nLoad qgraph network objects directly into ggsem. Make sure to specify type argument as network.\n\nlibrary(qgraph)\nlibrary(ggsem)\n\n# Create correlation network from mtcars data\ncor_matrix &lt;- cor(mtcars)\nqgraph_net &lt;- qgraph(cor_matrix, graph = \"pcor\")\n\n\n\n\n\n\n\nclass(qgraph_net) # class of the object\n\n[1] \"qgraph\"\n\n\n\n# Import directly into ggsem\nggsem(object = qgraph_net, type = 'network')\n\n\n\n\n\n\nFigure 8. A network diagram generated from pre-loaded qgraph object.\n\n\n\n\nThrough interactive visualization, you can modify properties of a specific node, edge or label (e.g., edge connecting carb and disp):\n\n\n\n\n\nFigure 9. A network diagram generated from pre-loaded qgraph object, with its one edge’s curvature modified through interactive parameter visualization.\n\n\n\n\n\n\nPractical qgraph Network Examples\n\nCorrelation Network with Thresholding\n\n# Correlation network with edge thresholding\ncor_matrix &lt;- cor(mtcars)\n\nqgraph_net &lt;- qgraph(cor_matrix,\n       graph = \"cor\",\n       minimum = 0.5,  # Hide edges below this threshold\n       maximum = 1,    # Upper threshold\n       layout = \"spring\",\n       edge.width = 2,\n       label.cex = 0.8,\n       labels = colnames(mtcars))\n\n\n\n\n\n\n\n\n\nggsem(object = qgraph_net, type = 'network')\n\n\n\n\n\n\nFigure 10. A network diagram generated from pre-loaded qgraph object.\n\n\n\n\n\n\nPartial Correlation Network\n\n# Partial correlation network controlling for other variables\nqgraph_net &lt;- qgraph(cor_matrix,\n       graph = \"pcor\",  # Partial correlations\n       layout = \"spring\",\n       sampleSize = nrow(mtcars),  # Important for pcor calculations\n       labels = colnames(mtcars),\n       theme = \"colorblind\")\n\n\n\n\n\n\n\nplot(qgraph_net)\n\n\nggsem(object = qgraph_net, type = 'network')\n\n\n\n\n\n\nFigure 11. A network diagram generated from pre-loaded qgraph object.\n\n\n\n\n\n\nGlasso Network (Regularized Partial Correlations)\n\n# Regularized partial correlation network using graphical lasso\nqgraph_net &lt;- qgraph(cor_matrix,\n       graph = \"glasso\",\n       layout = \"spring\",\n       sampleSize = nrow(mtcars), # Required for glasso estimation\n       tuning = 0.5,  # Regularization parameter\n       labels = colnames(mtcars),\n       theme = \"colorblind\")\n\nWarning in EBICglassoCore(S = S, n = n, gamma = gamma, penalize.diagonal =\npenalize.diagonal, : A dense regularized network was selected (lambda &lt; 0.1 *\nlambda.max). Recent work indicates a possible drop in specificity. Interpret\nthe presence of the smallest edges with care. Setting threshold = TRUE will\nenforce higher specificity, at the cost of sensitivity.\n\n\n\n\n\n\n\n\nplot(qgraph_net)\n\n\nggsem(object = qgraph_net, type = 'network')\n\n\n\n\n\n\nFigure 12. A network diagram generated from pre-loaded qgraph object.\n\n\n\n\n\n\n\nPreserved qgraph Features\n\nNetwork Properties Maintained:\n\nEdge weights and correlation values\nNode positions from qgraph layout algorithms\nColor schemes for nodes and edges\nThresholding and filtering settings\nEdge labels and correlation coefficients\n\n\n\nLayout Preservation:\n\nSpring, circle, and other qgraph layouts are maintained\nNode positioning transferred accurately to ggsem\nOption to further refine layout interactively in ggsem\n\n\n\n\nWhat are not preserved\n\nTitle\n\nDoes not inherit title, so you must re-create it if necessary.\n\n\n\nLegend\n\nggsem does not create legend.\n\n\n\nPolygon\n\nPolygon shapes to indicate cluster-based group",
    "crumbs": [
      "Single-Group Workflow Using Pre-loaded Objects",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Integrated Network Workflow</span>"
    ]
  },
  {
    "objectID": "network_preload.html#loading-network-objects",
    "href": "network_preload.html#loading-network-objects",
    "title": "11  Integrated Network Workflow",
    "section": "3. Loading network Objects",
    "text": "3. Loading network Objects\nFinally, the ggsem package provides support for network objects for plotting networks.\n\nDirect Network Object Import\nLoad network objects directly into ggsem:\n\nlibrary(network)\n\n\n'network' 1.18.2 (2023-12-04), part of the Statnet Project\n* 'news(package=\"network\")' for changes since last version\n* 'citation(\"network\")' for citation information\n* 'https://statnet.org' for help, support, and other information\n\n\n\nAttaching package: 'network'\n\n\nThe following objects are masked from 'package:igraph':\n\n    %c%, %s%, add.edges, add.vertices, delete.edges, delete.vertices,\n    get.edge.attribute, get.edges, get.vertex.attribute, is.bipartite,\n    is.directed, list.edge.attributes, list.vertex.attributes,\n    set.edge.attribute, set.vertex.attribute\n\nlibrary(ggsem)\n\n# Create a simple network object\nnet &lt;- network.initialize(10)  # 10 nodes\nnetwork::add.edges(net, tail = 1:9, head = 2:10)  # Create a chain\nnetwork.vertex.names(net) &lt;- letters[1:10]\n\nclass(net)  # Returns \"network\"\n\n[1] \"network\"\n\nplot(net)\n\n\n\n\n\n\n\n\n\n# Import directly into ggsem\nggsem(object = net, width = 35, height = 35)\n\n\n\n\n\n\nFigure 13. A network diagram generated from pre-loaded network object.\n\n\n\n\n\n\nBipartite Network Support\nCreate and import bipartite network objects with explicit partition structure:\n\n# Initialize network with 7 nodes (bipartite=3 means first 3 are type 0)\nnet &lt;- network.initialize(7, bipartite = 3, directed = FALSE)\n\n# Add edges (from type 0 to type 1)\nnetwork::add.edges(net, tail = c(1, 1, 2, 2, 3, 3),\n          head = c(4, 5, 5, 6, 6, 7))\n\n# Set node names\nnetwork.vertex.names(net) &lt;- c(1, 2, 3, \"A\", \"B\", \"C\", \"D\")\n\n# Create layout coordinates (two columns)\nx_pos &lt;- c(rep(1, 3), rep(2, 4))  # First set at x=1, second at x=2\ny_pos &lt;- c(3:1, 4:1)  # Spread vertically (adjust for spacing)\n\n# Plot with base R\npar(mar = c(1, 1, 3, 1))  # Adjust margins\n\nplot(net,\n     coord = cbind(x_pos, y_pos),  # Our bipartite layout\n     vertex.col = c(rep(\"lightblue\", 3), rep(\"salmon\", 4)),  # Color by set\n     vertex.cex = 3,\n     vertex.border = \"gray20\",\n     vertex.sides = c(rep(50, 3), rep(4, 4)),  # Circles and squares\n     edge.col = \"gray50\",\n     edge.lwd = 2,\n     displaylabels = TRUE,\n     label.pos = 5,  # Labels above nodes\n     label.cex = 1.2,\n     main = \"Bipartite Network (Base R)\")\n\n\n\n\n\n\n\n\n\n# Import bipartite network to ggsem\nggsem(object = net)\n\n\n\n\n\n\nFigure 14. A bipartite network diagram generated from pre-loaded network object. Color of the nodes in the top row has been modified.",
    "crumbs": [
      "Single-Group Workflow Using Pre-loaded Objects",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Integrated Network Workflow</span>"
    ]
  },
  {
    "objectID": "lavaan_semPaths_multigroup.html",
    "href": "lavaan_semPaths_multigroup.html",
    "title": "12  lavaan and/or semPaths",
    "section": "",
    "text": "Instead of starting with a blank canvas using ggsem(), you can pre-load multiple model and visualization objects to launch the app with existing content. There are three main approaches for working with multiple groups for lavaan objects using the pipe |&gt; operator (or %&gt;%). Some descriptions of these functions have already been descripted in Chapter 1:\n\nApproach 1: Single Multi-Group Model\nThis method uses lavaan’s built-in multi-group functionality, which is ideal for measurement invariance testing.\nUse case: Single multi-group model object where ggsem automatically extracts group-specific parameters.\n\nlibrary(lavaan)\nlibrary(semPlot)\nlibrary(ggsem)\n\nlavaan_string &lt;- \"visual  =~ x1 + x2 + x3\ntextual =~ x4 + x5 + x6\nspeed   =~ x7 + x8 + x9\"\n\n(fit &lt;- sem(lavaan_string, data = HolzingerSwineford1939, group = 'school'))\n\nlavaan 0.6-19 ended normally after 57 iterations\n\n  Estimator                                         ML\n  Optimization method                           NLMINB\n  Number of model parameters                        60\n\n  Number of observations per group:                   \n    Pasteur                                        156\n    Grant-White                                    145\n\nModel Test User Model:\n                                                      \n  Test statistic                               115.851\n  Degrees of freedom                                48\n  P-value (Chi-square)                           0.000\n  Test statistic for each group:\n    Pasteur                                     64.309\n    Grant-White                                 51.542\n\n\nModel Description: A single multi-group SEM object where the three-factor CFA is estimated separately for each school, allowing direct comparison of parameters across groups within one unified model framework.\n\nggsem_builder() |&gt;\n  add_group(name = \"Pasteur\", object = fit, x = -35) |&gt;\n  add_group(name =\"Grant-White\", object = fit, x = 35) |&gt;\n  launch()\n\nVisualization: ggsem automatically extracts group-specific parameters from the multi-group model and positions the Pasteur school diagram on the left (x = -35) and Grant-White on the right (x = 35) for side-by-side comparison.\n\n\n\n\n\nFigure 1. Two SEM diagrams side-by-side with unique color palettes.\n\n\n\n\nYou can also combine the two SEMs into one SEM diagram.\n\n\n\n\n\nFigure 2. Combine the two SEMs across groups into one diagram\n\n\n\n\nIf you add the title automatically using options in Aesthetic Grouping (see Chapter 16), this is the output:\n\n\n\n\n\nFigure 3. A combined SEM diagrams with automatically generated title.\n\n\n\n\n\n\nApproach 2: A Multi-Group Model with Pre-made Visualizations\nThis approach combines the statistical benefits of a multi-group model with customized visual layouts from semPlot.\nUse case: Pre-rendered diagrams for each group with explicit group-level specification using one model.\n\nsem_paths &lt;- semPaths(fit, layout = \"tree2\",\n                      what = \"paths\",\n                      title = TRUE,\n                      intercepts = TRUE,\n                      whatLabels = \"est\",\n                      style = \"lisrel\",\n                      residuals = FALSE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsem_paths1 &lt;- sem_paths[[1]]\nsem_paths2 &lt;- sem_paths[[2]]\n\nVisualizations: The multi-group semPaths output is split into two separate plot objects (sem_paths1 and sem_paths2), each containing the pre-rendered diagram for one school group with parameter estimates displayed.\n\nggsem_builder() |&gt;\n  add_group(\"Ptr\", model = fit, object = sem_paths1, x = -35, level = \"Pasteur\") |&gt;\n  add_group(\"GW\", model = fit, object = sem_paths2, x = 35, level = \"Grant-White\") |&gt;\n  launch()\n\nIntegration: Uses the same multi-group model object but with pre-rendered visualizations. The level parameter explicitly maps each diagram to its corresponding group in the model, ensuring the correct parameter estimates are displayed despite using identical model objects for both visualizations.\n\n\n\n\n\nFigure 4. Two SEM diagrams side-by-side with unique color palettes with slightly tilted orientations (+/- 5 degrees).\n\n\n\n\nWith this approach, you can also combine the two SEMs as shown in Figure 2.\n\n\n\n\n\nFigure 5. A combined SEM diagrams with automatically generated title.\n\n\n\n\n\n\nApproach 3: Separate Single-Group Models\nThis method treats each group as completely independent, fitting separate models to subsetted data.\nUse case: Completely independent models fitted to subgroup data.\n\nHolzingerSwineford1939P &lt;- HolzingerSwineford1939[which(HolzingerSwineford1939$school == 'Pasteur'),]\n\nHolzingerSwineford1939GW &lt;- HolzingerSwineford1939[which(HolzingerSwineford1939$school == 'Grant-White'),]\n\nfitP &lt;- sem(lavaan_string, data = HolzingerSwineford1939P)\n\nsem_pathsP &lt;- semPaths(fitP, layout = \"tree2\",\n                      what = \"paths\",\n                      title = TRUE,\n                      intercepts = TRUE,\n                      whatLabels = \"est\",\n                      style = \"lisrel\",\n                      residuals = FALSE)\n\n\n\n\n\n\n\nfitGW &lt;- sem(lavaan_string, data = HolzingerSwineford1939GW)\n\nsem_pathsGW &lt;- semPaths(fitGW, layout = \"tree2\",\n                       what = \"paths\",\n                       title = TRUE,\n                       intercepts = TRUE,\n                       whatLabels = \"est\",\n                       style = \"lisrel\",\n                       residuals = FALSE)\n\n\n\n\n\n\n\n\nAnalysis Workflow: The dataset is split into school-specific subsets, then identical three-factor CFA models are fitted independently to each school’s data, creating completely separate model and visualization objects with school-specific parameter estimates.\n\nggsem_builder() |&gt;\n  add_group(\"Ptr\", model = fitP, object = sem_pathsP, x = -35) |&gt;\n  add_group(\"GW\", model = fitGW, object = sem_pathsGW, x = 35) |&gt;\n  launch()\n\n\n\n\n\n\nFigure 6. Two SEM diagrams side-by-side with automatically generated titles.\n\n\n\n\nComparison: The interactive application positions the independently fitted Pasteur and Grant-White models side-by-side, allowing visual comparison of parameter estimates that were calculated separately for each school without multi-group constraints.\nWith this approach, you can also combine the two SEMs as shown in Figure 2.\n\n\n\n\n\nFigure 7. A combined SEM diagrams with automatically generated title and a different layout (spring)\n\n\n\n\n\n\nMix and Match\nYou can also upload unrelated multiple objects (SEM and networks) using add_group by specifying type argument in add_group():\n\n# Non-runnable code as variables are not properly defined\n# Plot SEM and Network together\nggsem_builder() |&gt;\n  add_group(\"SEM\", object = fitP, x = -35, type = \"sem\") |&gt;\n  add_group(\"Network\", object = igraph_object, x = 35, type = \"network\") |&gt;\n  launch()\n\nIf you pre-load different types of objects (even if they are both SEMs) that have different layouts/nodes/edges etc, you cannot combine the two SEMs as shown in Figure 2.",
    "crumbs": [
      "Multi-Group SEM Workflow Using Pre-loaded Objects",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>`lavaan` and/or `semPaths`</span>"
    ]
  },
  {
    "objectID": "blavaan_semPaths_multigroup.html",
    "href": "blavaan_semPaths_multigroup.html",
    "title": "13  blavaan and/or semPaths",
    "section": "",
    "text": "Instead of beginning with an empty workspace in ggsem(), you can load Bayesian structural equation modeling objects and associated visualizations to initialize the application with pre-existing content. There are three primary strategies for handling multiple groups using Bayesian estimation:\nNote: The first click of Apply Changes button for each group might be quite slow (or when you change layout or statistical annotations of the SEM diagram). This is because when the click is trigger, the app organizes all the metadata, and Bayesian SEM model (blavaan) is computationally heavy. See at the end of the chapter for an alternative solution.\n\nApproach 1: Single Multi-Group Model\nThis approach leverages blavaan’s integrated multi-group capability, particularly suitable for Bayesian measurement invariance analysis.\nUse case: A multi-group Bayesian model where ggsem retrieves group-specific parameter distributions.\n\nlibrary(blavaan)\nlibrary(lavaan)\nlibrary(semPlot)\nlibrary(ggsem)\n\nlavaan_string &lt;- \"visual  =~ x1 + x2 + x3\ntextual =~ x4 + x5 + x6\nspeed   =~ x7 + x8 + x9\"\n\nbfit &lt;- bsem(lavaan_string, data = HolzingerSwineford1939, group = 'school')\n\n\nSAMPLING FOR MODEL 'stanmarg' NOW (CHAIN 1).\nChain 1: \nChain 1: Gradient evaluation took 0.000623 seconds\nChain 1: 1000 transitions using 10 leapfrog steps per transition would take 6.23 seconds.\nChain 1: Adjust your expectations accordingly!\nChain 1: \nChain 1: \nChain 1: Iteration:    1 / 1500 [  0%]  (Warmup)\nChain 1: Iteration:  150 / 1500 [ 10%]  (Warmup)\nChain 1: Iteration:  300 / 1500 [ 20%]  (Warmup)\nChain 1: Iteration:  450 / 1500 [ 30%]  (Warmup)\nChain 1: Iteration:  501 / 1500 [ 33%]  (Sampling)\nChain 1: Iteration:  650 / 1500 [ 43%]  (Sampling)\nChain 1: Iteration:  800 / 1500 [ 53%]  (Sampling)\nChain 1: Iteration:  950 / 1500 [ 63%]  (Sampling)\nChain 1: Iteration: 1100 / 1500 [ 73%]  (Sampling)\nChain 1: Iteration: 1250 / 1500 [ 83%]  (Sampling)\nChain 1: Iteration: 1400 / 1500 [ 93%]  (Sampling)\nChain 1: Iteration: 1500 / 1500 [100%]  (Sampling)\nChain 1: \nChain 1:  Elapsed Time: 10.295 seconds (Warm-up)\nChain 1:                29.884 seconds (Sampling)\nChain 1:                40.179 seconds (Total)\nChain 1: \n\nSAMPLING FOR MODEL 'stanmarg' NOW (CHAIN 2).\nChain 2: \nChain 2: Gradient evaluation took 0.000394 seconds\nChain 2: 1000 transitions using 10 leapfrog steps per transition would take 3.94 seconds.\nChain 2: Adjust your expectations accordingly!\nChain 2: \nChain 2: \nChain 2: Iteration:    1 / 1500 [  0%]  (Warmup)\nChain 2: Iteration:  150 / 1500 [ 10%]  (Warmup)\nChain 2: Iteration:  300 / 1500 [ 20%]  (Warmup)\nChain 2: Iteration:  450 / 1500 [ 30%]  (Warmup)\nChain 2: Iteration:  501 / 1500 [ 33%]  (Sampling)\nChain 2: Iteration:  650 / 1500 [ 43%]  (Sampling)\nChain 2: Iteration:  800 / 1500 [ 53%]  (Sampling)\nChain 2: Iteration:  950 / 1500 [ 63%]  (Sampling)\nChain 2: Iteration: 1100 / 1500 [ 73%]  (Sampling)\nChain 2: Iteration: 1250 / 1500 [ 83%]  (Sampling)\nChain 2: Iteration: 1400 / 1500 [ 93%]  (Sampling)\nChain 2: Iteration: 1500 / 1500 [100%]  (Sampling)\nChain 2: \nChain 2:  Elapsed Time: 4.997 seconds (Warm-up)\nChain 2:                9.559 seconds (Sampling)\nChain 2:                14.556 seconds (Total)\nChain 2: \n\nSAMPLING FOR MODEL 'stanmarg' NOW (CHAIN 3).\nChain 3: \nChain 3: Gradient evaluation took 0.000405 seconds\nChain 3: 1000 transitions using 10 leapfrog steps per transition would take 4.05 seconds.\nChain 3: Adjust your expectations accordingly!\nChain 3: \nChain 3: \nChain 3: Iteration:    1 / 1500 [  0%]  (Warmup)\nChain 3: Iteration:  150 / 1500 [ 10%]  (Warmup)\nChain 3: Iteration:  300 / 1500 [ 20%]  (Warmup)\nChain 3: Iteration:  450 / 1500 [ 30%]  (Warmup)\nChain 3: Iteration:  501 / 1500 [ 33%]  (Sampling)\nChain 3: Iteration:  650 / 1500 [ 43%]  (Sampling)\nChain 3: Iteration:  800 / 1500 [ 53%]  (Sampling)\nChain 3: Iteration:  950 / 1500 [ 63%]  (Sampling)\nChain 3: Iteration: 1100 / 1500 [ 73%]  (Sampling)\nChain 3: Iteration: 1250 / 1500 [ 83%]  (Sampling)\nChain 3: Iteration: 1400 / 1500 [ 93%]  (Sampling)\nChain 3: Iteration: 1500 / 1500 [100%]  (Sampling)\nChain 3: \nChain 3:  Elapsed Time: 5.384 seconds (Warm-up)\nChain 3:                8.774 seconds (Sampling)\nChain 3:                14.158 seconds (Total)\nChain 3: \n\n\nComputing post-estimation metrics (including lvs if requested)...\n\n\nModel Description: A single multi-group Bayesian SEM object that estimates the three-factor confirmatory factor analysis separately for each school.\n\nggsem_builder() |&gt;\n  add_group(name = \"Pasteur\", object = bfit, x = -35) |&gt;\n  add_group(name =\"Grant-White\", object = bfit, x = 35) |&gt;\n  launch()\n\n\n\n\n\n\nFigure 1. Two Bayesian SEM diagrams side-by-side with unique color palettes.\n\n\n\n\nVisualization: ggsem extracts group-specific Bayesian parameter estimates from the multi-group model, arranging the Pasteur school visualization on the left (x = -35) and Grant-White on the right (x = 35).\nYou can also combine the two SEMs into one SEM diagram.\n\n\n\n\n\nFigure 2. Combine the two Bayesian SEMs across groups into one diagram\n\n\n\n\nIf you add the title automatically using options in Aesthetic Grouping (see Chapter 16), this is the output:\n\n\n\n\n\nFigure 3. A combined Bayesian SEM diagrams with automatically generated title.\n\n\n\n\nUsing interactive parameter visualization, you can modify the angle of one node group in the Latent Group Orientation submenu. The orientations of visual and speed node groups (with their associated intercept and observed nodes) have been modified.\n\n\n\n\n\nFigure 4. A combined SEM diagrams with automatically generated title and modified layout using interactive parameter visualization.\n\n\n\n\n\n\nApproach 2: A Multi-Group Model with Pre-configured Visualizations\nThis methodology combines the analytical advantages of a multi-group Bayesian framework with customized graphical representations from semPlot.\nUse case: Pre-generated diagrams for individual groups utilizing a single Bayesian model with group-specific display parameters.\n\nplot.new() # to prevent error, reset the plotting space\nsem_paths &lt;- semPaths(bfit, layout = \"tree2\",\n                      what = \"paths\",\n                      intercepts = TRUE,\n                      whatLabels = \"est\",\n                      style = \"lisrel\",\n                      residuals = FALSE)\nsem_paths1 &lt;- sem_paths[[1]]\nsem_paths2 &lt;- sem_paths[[2]]\n\nVisualizations: The multi-group semPaths output is split into two separate plot objects (sem_paths1 and sem_paths2), each containing the pre-rendered diagram for one school group with parameter estimates displayed.\n\nggsem_builder() |&gt;\n  add_group(\"Ptr\", model = bfit, object = sem_paths1, x = -35, level = \"Pasteur\") |&gt;\n  add_group(\"GW\", model = bfit, object = sem_paths2, x = 35, level = \"Grant-White\") |&gt;\n  launch()\n\n\n\n\n\n\nFigure 5. Two Bayesian SEM diagrams side-by-side with unique color palettes with different orientations (+/- 90 degrees).\n\n\n\n\nFirst, the layout of the second SEM group was flipped horizontally. Then, the orientation was modified for each group using options in the SEM Layout submenu (+/- 90 degrees).\nIntegration: Use the same multi-group Bayesian model object but with pre-loaded visualizations. The level parameter directly maps each diagram to its corresponding group in the model, so level has to match each group name in the original data file.\nWith this approach, you can also combine the two SEMs as shown in Figure 2.\n\n\n\n\n\nFigure 6. A combined Bayesian SEM diagrams with automatically generated title.\n\n\n\n\n\n\nApproach 3: Independent Single-Group Models\nThis strategy approaches each group as entirely separate entities, applying distinct Bayesian models to partitioned datasets.\nUse case: Fully autonomous Bayesian models applied to subgroup data with independent estimation procedures.\n\nHolzingerSwineford1939P &lt;- HolzingerSwineford1939[which(HolzingerSwineford1939$school == 'Pasteur'),]\n\nHolzingerSwineford1939GW &lt;- HolzingerSwineford1939[which(HolzingerSwineford1939$school == 'Grant-White'),]\n\nbfitP &lt;- bsem(lavaan_string, data = HolzingerSwineford1939P)\n\n\nSAMPLING FOR MODEL 'stanmarg' NOW (CHAIN 1).\nChain 1: \nChain 1: Gradient evaluation took 0.000212 seconds\nChain 1: 1000 transitions using 10 leapfrog steps per transition would take 2.12 seconds.\nChain 1: Adjust your expectations accordingly!\nChain 1: \nChain 1: \nChain 1: Iteration:    1 / 1500 [  0%]  (Warmup)\nChain 1: Iteration:  150 / 1500 [ 10%]  (Warmup)\nChain 1: Iteration:  300 / 1500 [ 20%]  (Warmup)\nChain 1: Iteration:  450 / 1500 [ 30%]  (Warmup)\nChain 1: Iteration:  501 / 1500 [ 33%]  (Sampling)\nChain 1: Iteration:  650 / 1500 [ 43%]  (Sampling)\nChain 1: Iteration:  800 / 1500 [ 53%]  (Sampling)\nChain 1: Iteration:  950 / 1500 [ 63%]  (Sampling)\nChain 1: Iteration: 1100 / 1500 [ 73%]  (Sampling)\nChain 1: Iteration: 1250 / 1500 [ 83%]  (Sampling)\nChain 1: Iteration: 1400 / 1500 [ 93%]  (Sampling)\nChain 1: Iteration: 1500 / 1500 [100%]  (Sampling)\nChain 1: \nChain 1:  Elapsed Time: 2.186 seconds (Warm-up)\nChain 1:                4.387 seconds (Sampling)\nChain 1:                6.573 seconds (Total)\nChain 1: \n\nSAMPLING FOR MODEL 'stanmarg' NOW (CHAIN 2).\nChain 2: \nChain 2: Gradient evaluation took 0.00023 seconds\nChain 2: 1000 transitions using 10 leapfrog steps per transition would take 2.3 seconds.\nChain 2: Adjust your expectations accordingly!\nChain 2: \nChain 2: \nChain 2: Iteration:    1 / 1500 [  0%]  (Warmup)\nChain 2: Iteration:  150 / 1500 [ 10%]  (Warmup)\nChain 2: Iteration:  300 / 1500 [ 20%]  (Warmup)\nChain 2: Iteration:  450 / 1500 [ 30%]  (Warmup)\nChain 2: Iteration:  501 / 1500 [ 33%]  (Sampling)\nChain 2: Iteration:  650 / 1500 [ 43%]  (Sampling)\nChain 2: Iteration:  800 / 1500 [ 53%]  (Sampling)\nChain 2: Iteration:  950 / 1500 [ 63%]  (Sampling)\nChain 2: Iteration: 1100 / 1500 [ 73%]  (Sampling)\nChain 2: Iteration: 1250 / 1500 [ 83%]  (Sampling)\nChain 2: Iteration: 1400 / 1500 [ 93%]  (Sampling)\nChain 2: Iteration: 1500 / 1500 [100%]  (Sampling)\nChain 2: \nChain 2:  Elapsed Time: 2.467 seconds (Warm-up)\nChain 2:                3.914 seconds (Sampling)\nChain 2:                6.381 seconds (Total)\nChain 2: \n\nSAMPLING FOR MODEL 'stanmarg' NOW (CHAIN 3).\nChain 3: \nChain 3: Gradient evaluation took 0.000173 seconds\nChain 3: 1000 transitions using 10 leapfrog steps per transition would take 1.73 seconds.\nChain 3: Adjust your expectations accordingly!\nChain 3: \nChain 3: \nChain 3: Iteration:    1 / 1500 [  0%]  (Warmup)\nChain 3: Iteration:  150 / 1500 [ 10%]  (Warmup)\nChain 3: Iteration:  300 / 1500 [ 20%]  (Warmup)\nChain 3: Iteration:  450 / 1500 [ 30%]  (Warmup)\nChain 3: Iteration:  501 / 1500 [ 33%]  (Sampling)\nChain 3: Iteration:  650 / 1500 [ 43%]  (Sampling)\nChain 3: Iteration:  800 / 1500 [ 53%]  (Sampling)\nChain 3: Iteration:  950 / 1500 [ 63%]  (Sampling)\nChain 3: Iteration: 1100 / 1500 [ 73%]  (Sampling)\nChain 3: Iteration: 1250 / 1500 [ 83%]  (Sampling)\nChain 3: Iteration: 1400 / 1500 [ 93%]  (Sampling)\nChain 3: Iteration: 1500 / 1500 [100%]  (Sampling)\nChain 3: \nChain 3:  Elapsed Time: 1.884 seconds (Warm-up)\nChain 3:                5.088 seconds (Sampling)\nChain 3:                6.972 seconds (Total)\nChain 3: \n\n\nComputing post-estimation metrics (including lvs if requested)...\n\nplot.new()\nsem_pathsP &lt;- semPaths(bfitP, layout = \"tree2\",\n                      what = \"paths\",\n                      title = TRUE,\n                      intercepts = TRUE,\n                      whatLabels = \"est\",\n                      style = \"lisrel\",\n                      residuals = FALSE)\n\n\n\n\n\n\n\nbfitGW &lt;- bsem(lavaan_string, data = HolzingerSwineford1939GW)\n\n\nSAMPLING FOR MODEL 'stanmarg' NOW (CHAIN 1).\nChain 1: \nChain 1: Gradient evaluation took 0.000298 seconds\nChain 1: 1000 transitions using 10 leapfrog steps per transition would take 2.98 seconds.\nChain 1: Adjust your expectations accordingly!\nChain 1: \nChain 1: \nChain 1: Iteration:    1 / 1500 [  0%]  (Warmup)\nChain 1: Iteration:  150 / 1500 [ 10%]  (Warmup)\nChain 1: Iteration:  300 / 1500 [ 20%]  (Warmup)\nChain 1: Iteration:  450 / 1500 [ 30%]  (Warmup)\nChain 1: Iteration:  501 / 1500 [ 33%]  (Sampling)\nChain 1: Iteration:  650 / 1500 [ 43%]  (Sampling)\nChain 1: Iteration:  800 / 1500 [ 53%]  (Sampling)\nChain 1: Iteration:  950 / 1500 [ 63%]  (Sampling)\nChain 1: Iteration: 1100 / 1500 [ 73%]  (Sampling)\nChain 1: Iteration: 1250 / 1500 [ 83%]  (Sampling)\nChain 1: Iteration: 1400 / 1500 [ 93%]  (Sampling)\nChain 1: Iteration: 1500 / 1500 [100%]  (Sampling)\nChain 1: \nChain 1:  Elapsed Time: 1.352 seconds (Warm-up)\nChain 1:                2.805 seconds (Sampling)\nChain 1:                4.157 seconds (Total)\nChain 1: \n\nSAMPLING FOR MODEL 'stanmarg' NOW (CHAIN 2).\nChain 2: \nChain 2: Gradient evaluation took 0.000169 seconds\nChain 2: 1000 transitions using 10 leapfrog steps per transition would take 1.69 seconds.\nChain 2: Adjust your expectations accordingly!\nChain 2: \nChain 2: \nChain 2: Iteration:    1 / 1500 [  0%]  (Warmup)\nChain 2: Iteration:  150 / 1500 [ 10%]  (Warmup)\nChain 2: Iteration:  300 / 1500 [ 20%]  (Warmup)\nChain 2: Iteration:  450 / 1500 [ 30%]  (Warmup)\nChain 2: Iteration:  501 / 1500 [ 33%]  (Sampling)\nChain 2: Iteration:  650 / 1500 [ 43%]  (Sampling)\nChain 2: Iteration:  800 / 1500 [ 53%]  (Sampling)\nChain 2: Iteration:  950 / 1500 [ 63%]  (Sampling)\nChain 2: Iteration: 1100 / 1500 [ 73%]  (Sampling)\nChain 2: Iteration: 1250 / 1500 [ 83%]  (Sampling)\nChain 2: Iteration: 1400 / 1500 [ 93%]  (Sampling)\nChain 2: Iteration: 1500 / 1500 [100%]  (Sampling)\nChain 2: \nChain 2:  Elapsed Time: 1.244 seconds (Warm-up)\nChain 2:                2.331 seconds (Sampling)\nChain 2:                3.575 seconds (Total)\nChain 2: \n\nSAMPLING FOR MODEL 'stanmarg' NOW (CHAIN 3).\nChain 3: \nChain 3: Gradient evaluation took 0.000183 seconds\nChain 3: 1000 transitions using 10 leapfrog steps per transition would take 1.83 seconds.\nChain 3: Adjust your expectations accordingly!\nChain 3: \nChain 3: \nChain 3: Iteration:    1 / 1500 [  0%]  (Warmup)\nChain 3: Iteration:  150 / 1500 [ 10%]  (Warmup)\nChain 3: Iteration:  300 / 1500 [ 20%]  (Warmup)\nChain 3: Iteration:  450 / 1500 [ 30%]  (Warmup)\nChain 3: Iteration:  501 / 1500 [ 33%]  (Sampling)\nChain 3: Iteration:  650 / 1500 [ 43%]  (Sampling)\nChain 3: Iteration:  800 / 1500 [ 53%]  (Sampling)\nChain 3: Iteration:  950 / 1500 [ 63%]  (Sampling)\nChain 3: Iteration: 1100 / 1500 [ 73%]  (Sampling)\nChain 3: Iteration: 1250 / 1500 [ 83%]  (Sampling)\nChain 3: Iteration: 1400 / 1500 [ 93%]  (Sampling)\nChain 3: Iteration: 1500 / 1500 [100%]  (Sampling)\nChain 3: \nChain 3:  Elapsed Time: 1.291 seconds (Warm-up)\nChain 3:                2.481 seconds (Sampling)\nChain 3:                3.772 seconds (Total)\nChain 3: \nComputing post-estimation metrics (including lvs if requested)...\n\nsem_pathsGW &lt;- semPaths(bfitGW, layout = \"tree2\",\n                       what = \"paths\",\n                       title = TRUE,\n                       intercepts = TRUE,\n                       whatLabels = \"est\",\n                       style = \"lisrel\",\n                       residuals = FALSE)\n\n\n\n\n\n\n\n\nAnalysis Workflow: The dataset is split into school-specific subsets, then identical three-factor CFA models are fitted independently to each school’s data, creating separate model and visualization objects with school-specific posterior distributions.\n\nggsem_builder() |&gt;\n  add_group(\"Ptr\", model = bfitP, object = sem_pathsP, x = -35) |&gt;\n  add_group(\"GW\", model = bfitGW, object = sem_pathsGW, x = 35) |&gt;\n  launch()\n\n\n\n\n\n\nFigure 7. Two Bayesian SEM diagrams side-by-side. One of them has a flipped layout.\n\n\n\n\nComparison: The interactive application positions the independently fitted Pasteur and Grant-White models side-by-side, allowing visual comparison of parameter estimates that were calculated separately for each school without multi-group constraints.\nWith this approach, you can also combine the two SEMs as shown in Figure 2. However, you cannot create combined SEM with one frequentist model (sem() from lavaan) and one Bayesian model (bsem() from blavaan).\n\n\n\n\n\nFigure 8. A combined SEM with vertically flipped layout and automatically generated title at bottom center.\n\n\n\n\nNote: blavaan object is computationally heavy, and it works slowly with semPlot function. Alternatively, try with tidySEM instead (next chapter).",
    "crumbs": [
      "Multi-Group SEM Workflow Using Pre-loaded Objects",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>`blavaan` and/or `semPaths`</span>"
    ]
  },
  {
    "objectID": "tidySEM_multigroup.html",
    "href": "tidySEM_multigroup.html",
    "title": "14  lavaan/blavaan + tidySEM",
    "section": "",
    "text": "You can combine tidySEM’s layout capabilities with lavaan or blavaan models for visualizations in ggsem. Both frequentist (lavaan) and Bayesian (blavaan) models work seamlessly with this workflow. blavaan objects work identically to how lavaan objects work with tidySEM package in ggsem.\n\nApproach 1: Multi-Group Model with a Shared tidySEM Layout\nThis method uses tidySEM’s layout specification with multi-group models for consistent visualization across groups.\nUse case: Single multi-group model object where ggsem automatically extracts group-specific parameters.\n\nlibrary(lavaan)\nlibrary(ggsem)\nlibrary(tidySEM)\nlibrary(blavaan)\n\nlavaan_string &lt;- 'visual =~ x1 + x2 + x3\n             textual =~ x4 + x5 + x6\n             speed =~ x7 + x8 + x9'\n\nfit &lt;- sem(lavaan_string, data = HolzingerSwineford1939, group = 'school')\nbfit &lt;- bsem(lavaan_string, data = HolzingerSwineford1939, group = 'school')\n\n\nSAMPLING FOR MODEL 'stanmarg' NOW (CHAIN 1).\nChain 1: \nChain 1: Gradient evaluation took 0.000699 seconds\nChain 1: 1000 transitions using 10 leapfrog steps per transition would take 6.99 seconds.\nChain 1: Adjust your expectations accordingly!\nChain 1: \nChain 1: \nChain 1: Iteration:    1 / 1500 [  0%]  (Warmup)\nChain 1: Iteration:  150 / 1500 [ 10%]  (Warmup)\nChain 1: Iteration:  300 / 1500 [ 20%]  (Warmup)\nChain 1: Iteration:  450 / 1500 [ 30%]  (Warmup)\nChain 1: Iteration:  501 / 1500 [ 33%]  (Sampling)\nChain 1: Iteration:  650 / 1500 [ 43%]  (Sampling)\nChain 1: Iteration:  800 / 1500 [ 53%]  (Sampling)\nChain 1: Iteration:  950 / 1500 [ 63%]  (Sampling)\nChain 1: Iteration: 1100 / 1500 [ 73%]  (Sampling)\nChain 1: Iteration: 1250 / 1500 [ 83%]  (Sampling)\nChain 1: Iteration: 1400 / 1500 [ 93%]  (Sampling)\nChain 1: Iteration: 1500 / 1500 [100%]  (Sampling)\nChain 1: \nChain 1:  Elapsed Time: 8.236 seconds (Warm-up)\nChain 1:                11.52 seconds (Sampling)\nChain 1:                19.756 seconds (Total)\nChain 1: \n\nSAMPLING FOR MODEL 'stanmarg' NOW (CHAIN 2).\nChain 2: \nChain 2: Gradient evaluation took 0.000404 seconds\nChain 2: 1000 transitions using 10 leapfrog steps per transition would take 4.04 seconds.\nChain 2: Adjust your expectations accordingly!\nChain 2: \nChain 2: \nChain 2: Iteration:    1 / 1500 [  0%]  (Warmup)\nChain 2: Iteration:  150 / 1500 [ 10%]  (Warmup)\nChain 2: Iteration:  300 / 1500 [ 20%]  (Warmup)\nChain 2: Iteration:  450 / 1500 [ 30%]  (Warmup)\nChain 2: Iteration:  501 / 1500 [ 33%]  (Sampling)\nChain 2: Iteration:  650 / 1500 [ 43%]  (Sampling)\nChain 2: Iteration:  800 / 1500 [ 53%]  (Sampling)\nChain 2: Iteration:  950 / 1500 [ 63%]  (Sampling)\nChain 2: Iteration: 1100 / 1500 [ 73%]  (Sampling)\nChain 2: Iteration: 1250 / 1500 [ 83%]  (Sampling)\nChain 2: Iteration: 1400 / 1500 [ 93%]  (Sampling)\nChain 2: Iteration: 1500 / 1500 [100%]  (Sampling)\nChain 2: \nChain 2:  Elapsed Time: 6.144 seconds (Warm-up)\nChain 2:                11.155 seconds (Sampling)\nChain 2:                17.299 seconds (Total)\nChain 2: \n\nSAMPLING FOR MODEL 'stanmarg' NOW (CHAIN 3).\nChain 3: \nChain 3: Gradient evaluation took 0.000309 seconds\nChain 3: 1000 transitions using 10 leapfrog steps per transition would take 3.09 seconds.\nChain 3: Adjust your expectations accordingly!\nChain 3: \nChain 3: \nChain 3: Iteration:    1 / 1500 [  0%]  (Warmup)\nChain 3: Iteration:  150 / 1500 [ 10%]  (Warmup)\nChain 3: Iteration:  300 / 1500 [ 20%]  (Warmup)\nChain 3: Iteration:  450 / 1500 [ 30%]  (Warmup)\nChain 3: Iteration:  501 / 1500 [ 33%]  (Sampling)\nChain 3: Iteration:  650 / 1500 [ 43%]  (Sampling)\nChain 3: Iteration:  800 / 1500 [ 53%]  (Sampling)\nChain 3: Iteration:  950 / 1500 [ 63%]  (Sampling)\nChain 3: Iteration: 1100 / 1500 [ 73%]  (Sampling)\nChain 3: Iteration: 1250 / 1500 [ 83%]  (Sampling)\nChain 3: Iteration: 1400 / 1500 [ 93%]  (Sampling)\nChain 3: Iteration: 1500 / 1500 [100%]  (Sampling)\nChain 3: \nChain 3:  Elapsed Time: 7.662 seconds (Warm-up)\nChain 3:                10.452 seconds (Sampling)\nChain 3:                18.114 seconds (Total)\nChain 3: \n\n\nComputing post-estimation metrics (including lvs if requested)...\n\nlay &lt;- get_layout(\"visual\", \"\", \"\",\"\",\"textual\",\"\",\"speed\",\"\", \"\",\n                  \"x1\", \"x2\", \"x3\", \"x4\", \"x5\", \"x6\", \"x7\", \"x8\", \"x9\", rows = 2)\n\ntidysem_object &lt;- prepare_graph(model = fit, layout = lay)\ntidysem_object_bayes &lt;- prepare_graph(model = bfit, layout = lay)\n\nplot(tidysem_object)\n\n\n\n\n\n\n\n\nWhile tidySEM can plot multiple SEMs at once using a multi-group model object, here we plot them with more aesthetic refinement using ggsem_builder() workflow with the pipe |&gt; operator.\nImplementation: You can create structured graph objects from multi-group models using tidySEM’s one layout system.\n\n# Multi-group visualization with positioning (works for both lavaan and blavaan)\nggsem_builder(type = 'sem') |&gt;\n  add_group('P', model = fit, object = tidysem_object, y = 25, level = 'Pasteur') |&gt;\n  add_group('GW', model = fit, object = tidysem_object, y = -25, level = 'Grant-White') |&gt;\n  launch()\n\n# Bayesian version works identically\nggsem_builder(type = 'sem') |&gt;\n  add_group('P', model = bfit, object = tidysem_object_bayes, y = 25, level = 'Pasteur') |&gt;\n  add_group('GW', model = bfit, object = tidysem_object_bayes, y = -25, level = 'Grant-White') |&gt;\n  launch()\n\nUse case: Unified multi-group analysis with consistent visual structure across groups.\nThis figure shows a composite multi-group SEM figure (two groups) with significantly different paths highlighted (red color) in ggsem.\n\n\n\n\n\nFigure 1. A composite multi-group SEM diagram with pre-loaded tidySEM visualization objects and lavaan model objects.\n\n\n\n\nYou can also generate a combined SEM of two groups with significantly different paths highlighted (Highlight Group Differences).\n\n\n\n\n\nFigure 2. A combined multi-group SEM diagram with pre-loaded tidySEM visualization objects and lavaan model objects.\n\n\n\n\n\n\nApproach 2: Separate Models with Shared Layout\nFit independent models to subgroup data while maintaining visual consistency through shared layout.\nUse case: Pre-rendered diagrams for each group with explicit group-level specification using one model.\n\n# Data preparation\nHolzingerSwineford1939P &lt;- HolzingerSwineford1939[HolzingerSwineford1939$school == 'Pasteur',]\nHolzingerSwineford1939GW &lt;- HolzingerSwineford1939[HolzingerSwineford1939$school == 'Grant-White',]\n\n# Frequentist models\nfitP &lt;- sem(lavaan_string, data = HolzingerSwineford1939P)\nfitGW &lt;- sem(lavaan_string, data = HolzingerSwineford1939GW)\n\ntidysem_objectP &lt;- prepare_graph(model = fitP, layout = lay)\ntidysem_objectGW &lt;- prepare_graph(model = fitGW, layout = lay)\n\nVisualization: Compare independently fitted models using identical layout structure.\n\nggsem_builder() |&gt;\n  add_group(\"Ptr\", model = fitP, object = tidysem_objectP, y = -20) |&gt;\n  add_group(\"GW\", model = fitGW, object = tidysem_objectGW, y = 20) |&gt;\n  launch()\n\nUse case: Independent group analyses with standardized visual presentation for direct comparison.\n\n\nApproach 3: Multi-Group Model with Different tidySEM Layouts\nUse a single multi-group model with customized tidySEM layouts for each group to highlight different visual perspectives while maintaining statistical consistency.\nUse case: Completely independent models fitted to subgroup data.\n\n# Multi-group model\nfit_multi &lt;- sem(lavaan_string, data = HolzingerSwineford1939, group = 'school')\n\n# Custom layouts for each group\nlay_pasteur &lt;- get_layout(\"visual\", \"\", \"\",\"\",\"textual\",\"\",\"speed\",\"\", \"\",\n                  \"x1\", \"x2\", \"x3\", \"x4\", \"x5\", \"x6\", \"x7\", \"x8\", \"x9\", rows = 2)\n\nlay_grantwhite &lt;- get_layout(\"\", \"visual\", \"\",\"textual\",\"\",\"\",\"\",\"speed\", \"\",\n                  \"x1\", \"x2\", \"x3\", \"x4\", \"x5\", \"x6\", \"x7\", \"x8\", \"x9\", rows = 2)\n\n# Prepare group-specific graph objects\ngraph_pasteur &lt;- prepare_graph(model = fit_multi, layout = lay_pasteur)\ngraph_grantwhite &lt;- prepare_graph(model = fit_multi, layout = lay_grantwhite)\n\nImplementation: Apply distinct visual organizations to the same multi-group model for comparative analysis.\n\nggsem_builder(type = 'sem') |&gt;\n  add_group('Pasteur', model = fit_multi, object = graph_pasteur, y = 20, level = 'Pasteur') |&gt;\n  add_group('Grant-White', model = fit_multi, object = graph_grantwhite, y = -20, level = 'Grant-White') |&gt;\n  launch()\n\nUse case: Comparative visualization of multi-group results using customized layouts that emphasize different aspects of the model structure for each group, while maintaining statistical consistency through shared parameter estimation.\nKey Note: All three approaches work identically with both lavaan and blavaan models. Simply replace sem() with bsem() and the visualization workflow remains unchanged.",
    "crumbs": [
      "Multi-Group SEM Workflow Using Pre-loaded Objects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>`lavaan/blavaan` + `tidySEM`</span>"
    ]
  },
  {
    "objectID": "openmx_multigroup.html",
    "href": "openmx_multigroup.html",
    "title": "15  OpenMx",
    "section": "",
    "text": "The ggsem package provides integration with OpenMx multi-group models. OpenMx uses a different multi-group architecture than lavaan, so I describe how ggsem handles the structure differences.\n\nMulti-Group Model with Component Subsetting\nOpenMx organizes multi-group models as containers with separate submodels for each group. ggsem accesses individual group components using the $ operator to extract each submodel.\n\nlibrary(OpenMx)\nlibrary(dplyr)\n\n# Use built-in data for reliability\ndata(HolzingerSwineford1939, package = \"lavaan\")\n\n# Simple preparation\nhs_data &lt;- HolzingerSwineford1939 %&gt;%\n  dplyr::select(-c(id, sex, ageyr, agemo, grade)) %&gt;%\n  mutate(school = as.factor(school)) %&gt;%\n  na.omit()\n\n# Check groups\ntable(hs_data$school)\n\n\nGrant-White     Pasteur \n        145         156 \n\n# Model for Pasteur school\n# Model for Pasteur school - COMPLETE with means and all variables\npasteur_data &lt;- hs_data[hs_data$school == \"Pasteur\", ]\ncor_matrix &lt;- cor(pasteur_data[, paste0(\"x\", 1:9)])\n\n# Use average correlations for starting values\navg_cor &lt;- mean(cor_matrix[upper.tri(cor_matrix)])\n\npasteur_model &lt;- mxModel(\n  \"Pasteur\",\n  type = \"RAM\",\n  mxData(pasteur_data, type = \"raw\"),\n  manifestVars = paste0(\"x\", 1:9),\n  latentVars = c(\"visual\", \"textual\", \"speed\"),\n\n  # Add unique labels to force estimation\n  mxPath(from = \"visual\", to = c(\"x1\", \"x2\", \"x3\"),\n         free = TRUE, values = c(0.5, 0.6, 0.7),\n         labels = c(\"v_x1\", \"v_x2\", \"v_x3\")),\n\n  mxPath(from = \"textual\", to = c(\"x4\", \"x5\", \"x6\"),\n         free = TRUE, values = c(0.5, 0.6, 0.7),\n         labels = c(\"t_x4\", \"t_x5\", \"t_x6\")),\n\n  mxPath(from = \"speed\", to = c(\"x7\", \"x8\", \"x9\"),\n         free = TRUE, values = c(0.5, 0.6, 0.7),\n         labels = c(\"s_x7\", \"s_x8\", \"s_x9\")),\n\n  # Residual variances with labels\n  mxPath(from = paste0(\"x\", 1:9), arrows = 2, free = TRUE,\n         values = runif(9, 0.5, 1.5),  # Random starting values\n         labels = paste0(\"e\", 1:9)),\n\n  # Factor variances (fixed for identification)\n  mxPath(from = c(\"visual\", \"textual\", \"speed\"), arrows = 2, free = FALSE, values = 1),\n\n  # Factor covariances with labels\n  mxPath(from = \"visual\", to = c(\"textual\", \"speed\"), arrows = 2, free = TRUE,\n         values = c(0.2, 0.3), labels = c(\"v_t\", \"v_s\")),\n  mxPath(from = \"textual\", to = \"speed\", arrows = 2, free = TRUE,\n         values = 0.4, labels = \"t_s\"),\n  mxPath(from = \"one\", to = paste0(\"x\", 1:9), free = TRUE, values = 0)\n)\n\n# Model for Grant-White school (same complete structure)\ngrantwhite_model &lt;- mxModel(\n  \"GrantWhite\",\n  type = \"RAM\",\n  mxData(hs_data[hs_data$school == \"Grant-White\", ], type = \"raw\"),\n  manifestVars = paste0(\"x\", 1:9),\n  latentVars = c(\"visual\", \"textual\", \"speed\"),\n\n  mxPath(from = \"visual\", to = c(\"x1\", \"x2\", \"x3\"), free = TRUE, values = 0.8),\n  mxPath(from = \"textual\", to = c(\"x4\", \"x5\", \"x6\"), free = TRUE, values = 0.8),\n  mxPath(from = \"speed\", to = c(\"x7\", \"x8\", \"x9\"), free = TRUE, values = 0.8),\n  mxPath(from = paste0(\"x\", 1:9), arrows = 2, free = TRUE, values = 1),\n  mxPath(from = c(\"visual\", \"textual\", \"speed\"), arrows = 2, free = FALSE, values = 1),\n  mxPath(from = \"visual\", to = c(\"textual\", \"speed\"), arrows = 2, free = TRUE, values = 0.3),\n  mxPath(from = \"textual\", to = \"speed\", arrows = 2, free = TRUE, values = 0.3),\n\n  # MEANS - THIS FIXES THE ERROR!\n  mxPath(from = \"one\", to = paste0(\"x\", 1:9), free = TRUE, values = 0)\n)\n\nmulti_group_model &lt;- mxModel(\n  \"Complete_CFA\",\n  pasteur_model,\n  grantwhite_model,\n  mxFitFunctionMultigroup(c(\"Pasteur\", \"GrantWhite\"))\n)\n\n# Fit the model\nmulti_group_fit &lt;- mxRun(multi_group_model)\nsummary(multi_group_fit)\n\nSummary of Complete_CFA \n \nfree parameters:\n                  name       matrix     row     col  Estimate  Std.Error A\n1                 v_x1    Pasteur.A      x1  visual 1.0473316 0.14076806  \n2                 v_x2    Pasteur.A      x2  visual 0.4123525 0.12319949  \n3                 v_x3    Pasteur.A      x3  visual 0.5969090 0.11494689 !\n4                 t_x4    Pasteur.A      x4 textual 0.9456743 0.07956291  \n5                 t_x5    Pasteur.A      x5 textual 1.1190492 0.08866225  \n6                 t_x6    Pasteur.A      x6 textual 0.8274256 0.06799169  \n7                 s_x7    Pasteur.A      x7   speed 0.5912989 0.10752563  \n8                 s_x8    Pasteur.A      x8   speed 0.6650247 0.10306935 !\n9                 s_x9    Pasteur.A      x9   speed 0.5451862 0.10426056  \n10                  e1    Pasteur.S      x1      x1 0.2983214 0.25355412  \n11                  e2    Pasteur.S      x2      x2 1.3337348 0.16413382 !\n12                  e3    Pasteur.S      x3      x3 0.9894940 0.14391555  \n13                  e4    Pasteur.S      x4      x4 0.4253831 0.07039727  \n14                  e5    Pasteur.S      x5      x5 0.4556318 0.08544656 !\n15                  e6    Pasteur.S      x6      x6 0.2898107 0.05137019  \n16                  e7    Pasteur.S      x7      x7 0.8202922 0.12599984 !\n17                  e8    Pasteur.S      x8      x8 0.5097286 0.11763193  \n18                  e9    Pasteur.S      x9      x9 0.6803304 0.11198152 !\n19                 v_t    Pasteur.S  visual textual 0.4837454 0.07971889  \n20                 v_s    Pasteur.S  visual   speed 0.2989513 0.12073466  \n21                 t_s    Pasteur.S textual   speed 0.3251488 0.10214976  \n22      Pasteur.M[1,1]    Pasteur.M       1      x1 4.9412388 0.09457179  \n23      Pasteur.M[1,2]    Pasteur.M       1      x2 5.9839743 0.09818130  \n24      Pasteur.M[1,3]    Pasteur.M       1      x3 2.4871804 0.09288117  \n25      Pasteur.M[1,4]    Pasteur.M       1      x4 2.8226498 0.09197603  \n26      Pasteur.M[1,5]    Pasteur.M       1      x5 3.9951932 0.10463372  \n27      Pasteur.M[1,6]    Pasteur.M       1      x6 1.9221604 0.07903468  \n28      Pasteur.M[1,7]    Pasteur.M       1      x7 4.4322768 0.08659993  \n29      Pasteur.M[1,8]    Pasteur.M       1      x8 5.5631421 0.07811851  \n30      Pasteur.M[1,9]    Pasteur.M       1      x9 5.4177341 0.07916073  \n31  GrantWhite.A[1,10] GrantWhite.A      x1  visual 0.7770105 0.10597269 !\n32  GrantWhite.A[2,10] GrantWhite.A      x2  visual 0.5720100 0.10263820 !\n33  GrantWhite.A[3,10] GrantWhite.A      x3  visual 0.7185769 0.09610376  \n34  GrantWhite.A[4,11] GrantWhite.A      x4 textual 0.9705146 0.07858121 !\n35  GrantWhite.A[5,11] GrantWhite.A      x5 textual 0.9606154 0.08265275  \n36  GrantWhite.A[6,11] GrantWhite.A      x6 textual 0.9349409 0.08083467  \n37  GrantWhite.A[7,12] GrantWhite.A      x7   speed 0.6792022 0.08926654 !\n38  GrantWhite.A[8,12] GrantWhite.A      x8   speed 0.8325938 0.09476948 !\n39  GrantWhite.A[9,12] GrantWhite.A      x9   speed 0.7185104 0.09689300  \n40   GrantWhite.S[1,1] GrantWhite.S      x1      x1 0.7148984 0.13128266  \n41   GrantWhite.S[2,2] GrantWhite.S      x2      x2 0.8991935 0.12388049 !\n42   GrantWhite.S[3,3] GrantWhite.S      x3      x3 0.5570105 0.10836399  \n43   GrantWhite.S[4,4] GrantWhite.S      x4      x4 0.3153084 0.06484788  \n44   GrantWhite.S[5,5] GrantWhite.S      x5      x5 0.4188806 0.07229359 !\n45   GrantWhite.S[6,6] GrantWhite.S      x6      x6 0.4060295 0.06920544  \n46   GrantWhite.S[7,7] GrantWhite.S      x7      x7 0.6004895 0.09539465  \n47   GrantWhite.S[8,8] GrantWhite.S      x8      x8 0.4011750 0.11323527 !\n48   GrantWhite.S[9,9] GrantWhite.S      x9      x9 0.5347975 0.10972337 !\n49 GrantWhite.S[10,11] GrantWhite.S  visual textual 0.5406679 0.08524567  \n50 GrantWhite.S[10,12] GrantWhite.S  visual   speed 0.5233481 0.10912631 !\n51 GrantWhite.S[11,12] GrantWhite.S textual   speed 0.3361345 0.10066923 !\n52   GrantWhite.M[1,1] GrantWhite.M       1      x1 4.9298833 0.09536344  \n53   GrantWhite.M[1,2] GrantWhite.M       1      x2 6.2000019 0.09196689  \n54   GrantWhite.M[1,3] GrantWhite.M       1      x3 1.9956890 0.08603809  \n55   GrantWhite.M[1,4] GrantWhite.M       1      x4 3.3172407 0.09311556  \n56   GrantWhite.M[1,5] GrantWhite.M       1      x5 4.7120696 0.09619227  \n57   GrantWhite.M[1,6] GrantWhite.M       1      x6 2.4689668 0.09396108  \n58   GrantWhite.M[1,7] GrantWhite.M       1      x7 3.9208420 0.08557367  \n59   GrantWhite.M[1,8] GrantWhite.M       1      x8 5.4882768 0.08687677  \n60   GrantWhite.M[1,9] GrantWhite.M       1      x9 5.3272036 0.08513933  \n\nModel Statistics: \n               |  Parameters  |  Degrees of Freedom  |  Fit (-2lnL units)\n       Model:             60                   2649              7364.395\n   Saturated:             NA                     NA                    NA\nIndependence:             NA                     NA                    NA\nNumber of observations/statistics: 301/2709\n\nInformation Criteria: \n      |  df Penalty  |  Parameters Penalty  |  Sample-Size Adjusted\nAIC:       2066.395               7484.395                 7514.895\nBIC:      -7753.740               7706.822                 7516.536\nCFI: NA \nTLI: 1   (also known as NNFI) \nRMSEA:  0  [95% CI (NA, NA)]\nProb(RMSEA &lt;= 0.05): NA\nTo get additional fit indices, see help(mxRefModels)\ntimestamp: 2025-12-18 17:15:50 \nWall clock time: 0.6764479 secs \noptimizer:  SLSQP \nOpenMx version number: 2.21.13 \nNeed help?  See help(mxSummary) \n\nclass(multi_group_fit) # ggsem does not work with MxModel class\n\n[1] \"MxModel\"\nattr(,\"package\")\n[1] \"OpenMx\"\n\nclass(multi_group_fit$Pasteur) # but ggsem works with MxRAMModel class, $ is used to \"subset\" a part of the multi-group model\n\n[1] \"MxRAMModel\"\nattr(,\"package\")\n[1] \"OpenMx\"\n\n\nImplementation: Access individual group models from the multi-group container and add them separately to ggsem_builder().\n\n# Multi-group visualization with component subsetting\nggsem_builder() |&gt;\n  add_group('Pasteur', object = multi_group_fit$Pasteur, x = -30) |&gt;\n  add_group('GrantWhite', object = multi_group_fit$GrantWhite, x = 30) |&gt;\n  launch()\n\nNote: Unlike lavaan’s integrated multi-group handling, OpenMx requires explicit component extraction, so when using ggsem_builder(), make sure to subset each group’s model using $.",
    "crumbs": [
      "Multi-Group SEM Workflow Using Pre-loaded Objects",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>`OpenMx`</span>"
    ]
  },
  {
    "objectID": "aesthetic_grouping.html",
    "href": "aesthetic_grouping.html",
    "title": "16  Aesthetic Grouping",
    "section": "",
    "text": "The Aesthetic Grouping feature in ggsem allows you to apply consistent visual styling to groups of unlocked elements. This functionality is only available for elements that are not locked and when working with non-lavaan, non-network diagrams (i.e., locked = FALSE, lavaan = FALSE, network = FALSE). Unlocked elements are shown as green rows in the output tables, instead of red or white.\n\n\n\n\n\nFigure 1. Aesthetic Grouping options are mainly applicable for elements in green rows in the output tables\n\n\n\n\nIn other words, you need to have pressed Finalize a SEM or Finalize a Network for SEM or Network elements respectively to use options in this menu for each group. The Finalize button works for one group at a time.\nUse Apply Changes to modify the aesthetics unless other buttons are presented.\n\n16.0.1 Group Aesthetics\n\n\n\n\n\nFigure 2. Group Aesthetics\n\n\n\n\nApply coordinated styling to different element types within selected groups:\n\nPoints: Modify color, size, shape, and transparency for unlocked nodes and points\nLines: Customize color, width, line type, and transparency for unlocked edges and paths\nAnnotations: Adjust color, size, font face, and transparency for unlocked text labels\nSelf-loop Arrows: Style color, width, and transparency for unlocked circular arrows\n\nUsage: Select a group from the dropdown menu, then choose the element type(s) you wish to style. All changes apply consistently to all unlocked elements within the selected group after clicking Apply Changes.\n\n\n16.0.2 Group Label Edit\n\n\n\n\n\nFigure 3. Group Label Edit\n\n\n\n\nManage and customize group labels for better organization and visualization:\n\nShow (or Update) Group Labels\n\nLabel Position: Choose from 8 positions (top, bottom, left, right, and corner placements)\nLabel Styling: Customize color, size, font family, and style\nAlignment: Labels can be relative to each group’s elements, or you can specify X and/or Y coordinates of labels to align.\nOffset Control: Adjust label distance from group elements\nNote: Also works for SEM (lavaan = TRUE) and network elements (network = TRUE)\nClick Show Group Labels to add or update group labels on your diagrams.\n\n\n\nRename Group Labels\n\nRename Group Labels?: Choose a group to rename using the dropdown.\nNew Group Name: Type new name of the selected group.\n\n\n\nModify Group Labels (By Rows)\nThis menu works by selecting rows in the output tables, and applies to selected rows only.\n\nReassign Labels: Select elements of other groups from output tables to existing groups\nRename Labels: Create new group labels for selected elements in the output tables\nClear Groups: Remove group assignments from selected elements in the output tables\n\n\n\nDelete Group Labels\n\nDelete Groups: Remove all elements associated with a specific group\nLock Groups: Protect groups from further modification while maintaining visibility. This sets lock = TRUE\n\n\n\n\n16.0.3 Group Position\n\n\n\n\n\nFigure 4. Group Position\n\n\n\n\nTransform the spatial arrangement of element groups:\n\nPosition XY Shift\n\nMove entire groups horizontally or vertically while maintaining internal spatial relationships\nGroup is specified using the Which Group to Modify dropdown at the top.\n\n\n\nAlign Groups\n\nAlignment Methods: Horizontal centers, vertical centers, or edge alignment (left, right, top, bottom)\nMulti-group Selection: Align multiple groups simultaneously for consistent layout\nRelative Positioning: Maintain current spatial relationships while applying alignment\nGroups are selected using Groups to align box. This works when there are two or more groups.",
    "crumbs": [
      "Others",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Aesthetic Grouping</span>"
    ]
  },
  {
    "objectID": "metadata.html",
    "href": "metadata.html",
    "title": "17  Storing Outputs and Metadata Across Sessions",
    "section": "",
    "text": "1. Save Output Tables as CSVs\nYou can save output tables from the app in csv formats. These can be re-uploaded in the app directly, and they can also be converted to plot outputs using the function csv_to_ggplot(). However, it does not save the history of the entire session from the app.\nExample of this method is in Chapter 3 in section 2, as pasted here:\nlibrary(ggsem)\n\npoints &lt;- read.csv('batch/points_batch.csv') \nlines &lt;- read.csv('batch/lines_batch.csv') \nannotations &lt;- read.csv('batch/annotations_batch.csv') \n\nggsem_data &lt;- list(points, lines, annotations) # Put them in a list, any order is fine\n\nplot3 &lt;- csv_to_ggplot(ggsem_data)\n\nsave_figure('plot3.png', plot3)",
    "crumbs": [
      "Others",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Storing Outputs and Metadata Across Sessions</span>"
    ]
  },
  {
    "objectID": "metadata.html#save-metadata-to-capture-entire-workflow-history",
    "href": "metadata.html#save-metadata-to-capture-entire-workflow-history",
    "title": "17  Storing Outputs and Metadata Across Sessions",
    "section": "2. Save Metadata to Capture Entire Workflow History",
    "text": "2. Save Metadata to Capture Entire Workflow History\nAdditionally, you can save the entire metadata from one session of the app by clicking Capture Complete Workflow, and then Download Complete Workflow. This metadata can be converted into a ggplot object using metadata_to_ggplot().\n\nlibrary(tidyverse)\nlibrary(ggsem)\n\nmetadata &lt;- readRDS('ggsem_metadata.rds') # load metadata from the app\nplot1 &lt;- metadata_to_ggplot(metadata) # convert RDS into a list of data frames (output tables)\n\nsave_figure('plot1.png', plot1)\n\n\n\n\n\n\nFigure 1. Save and load metadata (RDS) file\n\n\n\n\nIf you want to manually edit data frames containing information about graphics, you can use ggsem_silent() instead, which returns a list of output tables. ggsem_silent() re-runs the whole session’s metadata and reproduces the same diagram outputs. The output of ggsem_silent() can be converted into ggplot object using csv_to_ggplot().\n\nlibrary(ggsem)\n\nmetadata &lt;- readRDS('ggsem_metadata.rds') # load metadata from the app\nggsem_data &lt;- ggsem_silent(metadata) # edit ggsem_data \nplot1 &lt;- csv_to_ggplot(ggsem_data) # convert RDS into a list of data frames (output tables)\n\nsave_figure('plot1.png', plot1)\n\n\nSave Current Work\nCapture Complete Workflow:\n\nRecords all aspects of your current session including:\n\nAll group definitions and configurations\nStatistical models and parameter estimates\nImported data files and datasets\nVisual elements, layouts, and aesthetic settings\nCurrent diagram state and positioning\n\n\nDownload Complete Workflow:\n\nExports workflow as a portable .rds file\nEnables figure reproduction without relaunching the Shiny app\nPreserves all analytical and visual components for future use\nSupports collaborative sharing and publication reproducibility\n\n\n\nContinue Previous Work\nUpload Workflow to Continue:\n\nLoad previously saved .rds workflow files\nRestore complete analysis environment exactly as saved\nResume work from any previous session state\nMaintain all model specifications, data, and visual customizations\nWorkflow can be replayed using Redo and Undo buttons\n\n\n\nMetadata Status\nWorkflow Summary:\n\nDisplays current session metadata including:\n\nNumber of groups for SEM and networks\nSession click counts and other information",
    "crumbs": [
      "Others",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Storing Outputs and Metadata Across Sessions</span>"
    ]
  }
]